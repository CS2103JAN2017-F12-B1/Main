# A0140016B
###### \java\savvytodo\commons\util\DateTimeUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to DateTime
 */
public class DateTimeUtil {

    private static final String TIME_ONLY_FORMAT = "HHmm";
    private static final String DATE_ONLY_FORMAT = "dd/MM/yyyy";
    private static final String DATE_FORMAT = "d/M/uuuu HHmm";
    public static final String DATE_STRING_FORMAT = "dd/MM/yyyy HHmm";

    public static final int FIRST_HOUR_OF_DAY = 0;
    public static final int FIRST_MINUTE_OF_DAY = 0;
    public static final int FIRST_SECOND_OF_DAY = 0;
    public static final int LAST_HOUR_OF_DAY = 23;
    public static final int LAST_MINUTE_OF_DAY = 59;
    public static final int LAST_SECOND_OF_DAY = 59;

    private static final String DAILY = "daily";
    private static final String WEEKLY = "weekly";
    private static final String MONTHLY = "monthly";
    private static final String YEARLY = "yearly";
    private static final int INCREMENT_FREQ = 1;

    private static final DateTimeFormatter DATE_ONLY_FORMATTER = DateTimeFormatter
            .ofPattern(DATE_ONLY_FORMAT);
    private static final DateTimeFormatter TIME_ONLY_FORMATTER = DateTimeFormatter
            .ofPattern(TIME_ONLY_FORMAT);

    public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT)
            .withResolverStyle(ResolverStyle.STRICT);
    public static final DateTimeFormatter DATE_STRING_FORMATTER = DateTimeFormatter
            .ofPattern(DATE_STRING_FORMAT);

    public static final String MESSAGE_INCORRECT_SYNTAX = "It must be a valid date";

    private static final String MESSAGE_DURATION = "%1$s hr %2$s min";

    public static final String MESSAGE_FREE_TIME_SLOT = StringUtil.SYSTEM_NEWLINE
            + "%1$s. %2$shrs to %3$shrs (%4$s)";

    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return String[] with first index being the start DateTime and second index being the end
     *         date Time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) throws IllegalValueException {
        return NattyDateTimeParserUtil.parseStringToDateTime(dateTimeArgs);
    }

    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return LocalDateTime
     */
    private static LocalDateTime parseStringToLocalDateTime(String dateTime) {
        return LocalDateTime.parse(dateTime, DATE_FORMATTER);
    }

    /**
     * Checks if given endDateTime is within today and the end of this week
     */
    public static boolean isWithinWeek(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime endThisWeek = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY))
                    .withHour(0).withMinute(0).withSecond(0);
            return endDateTime.isAfter(now) && endDateTime.isBefore(endThisWeek);
        }
    }

    /**
     * Checks if given event's endDateTime is before the end of today
     */
    public static boolean isOverDue(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            return endDateTime.isBefore(now);
        }
    }

    /**
     * Checks whether the dateTimeQuery falls within the range of the dateTimeSource
     * i.e. dateTimeQuery start is equals to or before the dateTimeSource end
     * && dateTimeQuery end is equals to or after the dateTimeSource start
     * Return false if task is a deadline or floating task (i.e. no start or end)
     * @param dateTimeSource is event compare to
     * @param dateTimeQuery  is event compare with
     */
    public static boolean isDateTimeWithinRange(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return !dateTimeOriginal.getEndDate().isBefore(dateTimeCompare.getStartDate())
                && !dateTimeOriginal.getStartDate().isAfter(dateTimeCompare.getEndDate());
    }

    /**
     * Checks whether the dateTimeQuery conflicts with the dateTimeSource
     * i.e. dateTimeQuery end should occur after the dateTimeSource start
     * and dateTimeQuery start should occur before the dateTimeSource end
     * Return false if task is a deadline or floating task (i.e. no start or end)
     */
    public static boolean isDateTimeConflict(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return dateTimeOriginal.getEndDate().isAfter(dateTimeCompare.getStartDate())
                && dateTimeOriginal.getStartDate().isBefore(dateTimeCompare.getEndDate());
    }

    private static DateTime fillDateTime(DateTime filledDateTime) throws IllegalValueException {

        filledDateTime.setEnd(parseStringToLocalDateTime(filledDateTime.endValue));
        filledDateTime.setStart(parseStringToLocalDateTime(filledDateTime.startValue));

        return filledDateTime;
    }

    /**
     * Check whether eventDateTime is an event
     * @param eventDateTime
     * @return whether task is an event
     */
    private static boolean isEvent(DateTime eventDateTime) {
        if (eventDateTime.getStartDate() == null || eventDateTime.getEndDate() == null) {
            return false;
        }

        return true;
    }

    /**
     * Check whether dateTimeSource and dateTimeQuery are events before they can be compared
     * @param dateTimeSource is the event compared to
     * @param dateTimeQuery is the event to compare
     * @return whether the task compared to and with are events
     */
    private static boolean areEvents(DateTime dateTimeSource, DateTime dateTimeQuery) {
        return isEvent(dateTimeSource) && isEvent(dateTimeQuery);
    }

    /**
     * @param dateToCheck cannot be null and it must be an event
     * @return an ArrayList<DateTime> of free slots in a specified date
     * else return an empty ArrayList
     */
    public static ArrayList<DateTime> getListOfFreeTimeSlotsInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFilledTimeSlotsInDate) {
        ArrayList<DateTime> listOfFreeTimeSlots = new ArrayList<DateTime>();
        if (isEvent(dateToCheck)) {
            LocalDateTime startDateTime = dateToCheck.getStartDate();
            LocalDateTime endDateTime = dateToCheck.getEndDate();

            for (DateTime dateTime : listOfFilledTimeSlotsInDate) {
                if (dateTime.getStartDate() == null) {
                    continue;
                } else {
                    endDateTime = dateTime.getStartDate();
                }

                if (startDateTime.isBefore(endDateTime)) {
                    listOfFreeTimeSlots.add(new DateTime(startDateTime, endDateTime));
                }

                if (startDateTime.isBefore(dateTime.getEndDate())) {
                    startDateTime = dateTime.getEndDate();
                }
            }

            if (startDateTime.isBefore(dateToCheck.getEndDate())) {
                listOfFreeTimeSlots.add(new DateTime(startDateTime, dateToCheck.getEndDate()));
            }
        }

        return listOfFreeTimeSlots;
    }

    /**
     * @return String from normal DateTime Object
     */
    public static String getDayAndDateString(DateTime dateTime) {
        StringBuilder sb = new StringBuilder();

        sb.append(
                dateTime.getEndDate().getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH))
                .append(",").append(dateTime.getEndDate().format(DATE_ONLY_FORMATTER));

        return sb.toString();
    }

    /**
     * @return String of Free DateTime In Date
     */
    public static String getStringOfFreeDateTimeInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFreeTimeSlotsInDate) {
        StringBuilder sb = new StringBuilder();

        sb.append(getDayAndDateString(dateToCheck)).append(":");

        int counter = 1;

        for (DateTime dateTime : listOfFreeTimeSlotsInDate) {
            sb.append(String.format(MESSAGE_FREE_TIME_SLOT, counter,
                    dateTime.getStartDate().format(TIME_ONLY_FORMATTER),
                    dateTime.getEndDate().format(TIME_ONLY_FORMATTER),
                    getDurationBetweenTwoLocalDateTime(dateTime.getStartDate(),
                            dateTime.getEndDate())));
            counter++;
        }

        return sb.toString();
    }

    /**
     * Calculate the duration between 2 dates
     * @param startDateTime is not null
     * @param endDateTime is not null
     * @return String duration between 2 dates
     */
    public static String getDurationBetweenTwoLocalDateTime(LocalDateTime startDateTime,
            LocalDateTime endDateTime) {
        Duration duration = Duration.between(startDateTime, endDateTime);
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;

        return String.format(MESSAGE_DURATION, hours, minutes);
    }

    /**
     * Modify the date based on the new hour, min and sec
     * @return Date
     */
    public static Date setDateTime(Date toBeEdit, int hour, int min, int sec) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(toBeEdit);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, min);
        calendar.set(Calendar.SECOND, sec);
        toBeEdit = calendar.getTime();

        return toBeEdit;
    }

    /**
     * @param recurDate usually is the start date of an event
     * @param freqType is the frequency based on recurrance
     * Modifies the recurDate based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    public static String getRecurDate(String recurDate, String freqType) {
        LocalDateTime date = LocalDateTime.parse(recurDate, DATE_FORMATTER);

        switch (freqType.toLowerCase()) {
        case DAILY:
            date = date.plusDays(INCREMENT_FREQ);
            break;
        case WEEKLY:
            date = date.plusWeeks(INCREMENT_FREQ);
            break;
        case MONTHLY:
            date = date.plusMonths(INCREMENT_FREQ);
            break;
        case YEARLY:
            date = date.plusYears(INCREMENT_FREQ);
            break;
        }

        recurDate = date.format(DATE_STRING_FORMATTER);
        return recurDate;
    }

    /**
     * @param recurDates usually is the start date of an event
     * @param freqType is the frequency based on recurrence
     * @param noOfRecurr is the number of recurrence
     * Modifies the recurDates based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    public static ArrayList<String> getRecurDates(String recurDate, String freqType,
            int noOfRecurr) {
        ArrayList<String> recurrDates = new ArrayList<String>();

        for (int i = 0; i < noOfRecurr; i++) {
            recurDate = getRecurDate(recurDate, freqType);
            recurrDates.add(getRecurDate(recurDate, freqType));
        }

        return recurrDates;
    }

    /**
     * @param dateTime in LocalDateTime which has been initialized with a date
     * @param hour in int that is to be changed in hour
     * @param min in int that is to be changed in min
     * @param sec in int that is to be changed in sec
     * @return LocalDateTime which is modified with new time
     */
    public static LocalDateTime setLocalTime(LocalDateTime dateTime, int hour, int min, int sec) {
        return LocalDateTime.of(dateTime.getYear(), dateTime.getMonth(), dateTime.getDayOfMonth(),
                hour, min, sec);
    }

```
###### \java\savvytodo\commons\util\EnumUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to Enum
 */
public class EnumUtil {
    /**
     * for seed properties
     * @param e
     * @return String []
     */
    public static String[] getNames(Class<? extends Enum<?>> e) {
        return Arrays.stream(e.getEnumConstants()).map(Enum::name).toArray(String[]::new);
    }
}
```
###### \java\savvytodo\commons\util\NattyDateTimeParserUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to NattyDateTimeParser
 */
public class NattyDateTimeParserUtil {

    private static final int EMPTY_GROUP_SIZE = 0;
    private static final int END_DATE_GROUP_SIZE = 1;
    private static final int START_AND_END_DATE_GROUP_SIZE = 2;
    private static final int GROUP_ONE = 0;
    private static final int GROUP_TWO = 1;
    private static final int CHILD_ONE = 0;
    private static final int CHILD_TWO = 1;

    private static final SimpleDateFormat CONVERT_TIME_FORMAT = new SimpleDateFormat("dd/MM/yyyy HHmm");

    private static final String DASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})-(\\d{1,2})";
    private static final String SLASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})/(\\d{1,2})";
    public static final String EQUAL_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})=(\\d{1,2})";
    public static final String EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2}) = (\\d{1,2})";

    private static final String DASH_CONNECTOR_DATE_REPLACEMENT = "$2-$1";
    private static final String SLASH_CONNECTOR_DATE_REPLACEMENT = "$2/$1";
    private static final String WORD_NOW = "NOW";
    private static final String NATTY_EXPLICT_TIME_PREFIX = "EXPLICIT_TIME";

    private static Parser parser;

    /**
     * To create one instance of parser so that computation would be relatively faster
     * @return Parser instance if it exist else return a new Parser with TimeZone
     */
    private static Parser getInstance() {
        if (parser == null) {
            return new Parser(TimeZone.getDefault());
        } else {
            return parser;
        }
    }

    /**
     * Extracts the new task's dateTime from the string arguments using natty.
     * @param String dateTimeArgs
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) throws IllegalValueException {
        String endDateTime = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String formattedDateTimeArg = convertToUSDateFormat(dateTimeArgs);
        if (formattedDateTimeArg.contains(DateTime.DATETIME_STRING_CONNECTOR)) {
            formattedDateTimeArg.replaceAll(DateTime.DATETIME_STRING_CONNECTOR, DateTime.DATETIME_STRING_TO_CONNECTOR);
        }

        parser = getInstance();
        List<DateGroup> groups = parser.parse(formattedDateTimeArg);

        if (isInvalidDateTimeArg(dateTimeArgs, groups)) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_DATETIME);
        }

        if (groups.size() > EMPTY_GROUP_SIZE) {
            DateGroup group = groups.get(GROUP_ONE);
            if (group.getDates().size() == END_DATE_GROUP_SIZE) {
                return retrieveEndDate(group);
            }

            if (group.getDates().size() == START_AND_END_DATE_GROUP_SIZE) {
                return retrieveStartAndEndDate(group);
            }
        }

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Change the date format to US date format.
     * @param unformattedDateTime
     * @return formatted DateTime in US format
     */
    private static String convertToUSDateFormat(String unformattedDateTime) {
        String formattedDateTime = unformattedDateTime.trim()
                .replaceAll(DASH_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(SLASH_CONNECTOR_DATE_FORMAT, SLASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT);
        return formattedDateTime;
    }

    /**
     * Change the date format to Asia date format.
     * @param unformattedDateTime
     * @return formatted DateTime in Asia format
     */
    private static String convertToAsiaDateFormat(Date unformattedDateTime) {
        return CONVERT_TIME_FORMAT.format(unformattedDateTime);
    }

    /**
     * Checks if the DateTime is a invalid format.
     * @return true if the given DateTime is invalid
     */
    private static boolean isInvalidDateTimeArg(String dateTimeArg, List<DateGroup> groups) {
        return (dateTimeArg.trim().length() > 0 && groups.size() == EMPTY_GROUP_SIZE);
    }

    /**
     * Retrieve end date time from natty group for deadlines
     */
    private static String[] retrieveEndDate(DateGroup group) {
        String treeString = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date date;

        treeString = group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();

        date = group.getDates().get(GROUP_ONE);
        if (!isTimePresent(treeString) && !isWordNowPresent(group.getText())) {
            date = DateTimeUtil.setDateTime(date,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        endDateTime = convertToAsiaDateFormat(date);

        return new String[] {StringUtil.EMPTY_STRING, endDateTime};
    }

    /**
     * Retrieve the variables from Natty Parser for events
     */
    private static String[] retrieveStartAndEndDate(DateGroup group) {
        String treeFirstString = StringUtil.EMPTY_STRING;
        String treeSecondString = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date dateOne;
        Date dateTwo;

        treeFirstString =
                group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();
        treeSecondString =
                group.getSyntaxTree().getChild(CHILD_TWO).toStringTree();
        dateOne = group.getDates().get(GROUP_ONE);
        dateTwo = group.getDates().get(GROUP_TWO);

        if (!isTimePresent(treeFirstString) && !isWordNowPresent(group.getText())) {
            dateOne = DateTimeUtil.setDateTime(dateOne,
                    DateTimeUtil.FIRST_HOUR_OF_DAY,
                    DateTimeUtil.FIRST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        if (!isTimePresent(treeSecondString) && !isWordNowPresent(group.getText())) {
            dateTwo = DateTimeUtil.setDateTime(dateTwo,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        startDateTime = CONVERT_TIME_FORMAT.format(dateOne);
        endDateTime = CONVERT_TIME_FORMAT.format(dateTwo);

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Checks if time is present
     * @param treeString
     * @return true if time is present
     */
    private static boolean isTimePresent(String treeString) {
        return treeString.contains(NATTY_EXPLICT_TIME_PREFIX);
    }

    /**
     * Checks if word now is present
     * @param arg
     * @return true if word now is present
     */
    private static boolean isWordNowPresent(String arg) {
        return arg.toLowerCase().contains(WORD_NOW.toLowerCase());
    }
}
```
###### \java\savvytodo\commons\util\StringUtil.java
``` java
    /**
     * @author A0140016B
     * @param string cannot be null
     * @param string Should be trimmed
     * @return string of first character upper case and the rest lower case
     */
    public static String firstCharUpperCaseRestLowerCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1).toLowerCase();
    }

}
```
###### \java\savvytodo\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: NAME [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " "
            + "Project Meeting dt/05/10/2016 1400 = 05/10/2016 1800 r/weekly 2 c/CS2103 "
            + "d/Discuss about roles and milestones";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";


    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String priority, String description, String location, String[] dateTime,
            String[] recurrence, Set<String> categories) throws IllegalValueException {
        final Set<Category> categorySet = new HashSet<>();
        for (String categoryName : categories) {
            categorySet.add(new Category(categoryName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Priority(priority),
                new Description(description),
                new Location(location),
                new UniqueCategoryList(categorySet),
                new DateTime(dateTime),
                new Recurrence(recurrence)
        );

        this.toAdd.setStatus(new Status());
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            String conflictingTaskList = model.getTaskConflictingDateTimeWarningMessage(toAdd.getDateTime());
            model.addTask(toAdd);
            return new CommandResult(String.format(messageSummary(conflictingTaskList), toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (DateTimeException e) {
            throw new CommandException(DateTimeUtil.MESSAGE_INCORRECT_SYNTAX);
        } catch (IllegalValueException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }

    /**
     * Method for conflicting tasks
     * @param conflictingTaskList
     * @return messageSummary
     */
    private String messageSummary(String conflictingTaskList) {
        String summary = MESSAGE_SUCCESS;
        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.SYSTEM_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }
        return summary;
    }
}
```
###### \java\savvytodo\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the at least one details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "[NAME] [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " 1 c/CS2103 d/Complete group project component";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final TaskIndex filteredTaskListIndex;
    private final CommandTaskDescriptor cmdTaskDescriptor;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(TaskIndex filteredTaskListIndex, CommandTaskDescriptor cmdTaskDescriptor) {
        assert filteredTaskListIndex.getIndex() > 0;
        assert cmdTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex;

        this.cmdTaskDescriptor = new CommandTaskDescriptor(cmdTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList(filteredTaskListIndex.getTaskType());

        if (filteredTaskListIndex.getIndex() - 1 >= lastShownList.size() || filteredTaskListIndex.getIndex() < 0) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex.getIndex() - 1);
        Task editedTask = createEditedTask(taskToEdit, cmdTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex.getIndex() - 1, taskToEdit, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code cmdTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, CommandTaskDescriptor cmdTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = cmdTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Priority updatedPriority = cmdTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        Description updatedDescription = cmdTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        Location updatedLocation = cmdTaskDescriptor.getLocation().orElseGet(taskToEdit::getLocation);
        UniqueCategoryList updatedCategories = cmdTaskDescriptor.getCategories().orElseGet(taskToEdit::getCategories);
        DateTime updatedDateTime = cmdTaskDescriptor.getDateTime().orElseGet(taskToEdit::getDateTime);
        Recurrence updatedRecurrence = cmdTaskDescriptor.getRecurrence().orElseGet(taskToEdit::getRecurrence);
        Status updatedStatus = cmdTaskDescriptor.getStatus().orElseGet(taskToEdit::isCompleted);
        TimeStamp timeStamp = taskToEdit.getTimeStamp();
        return new Task(updatedName, updatedPriority, updatedDescription, updatedLocation, updatedCategories,
                updatedDateTime, updatedRecurrence, updatedStatus, timeStamp);
    }

}
```
###### \java\savvytodo\logic\commands\MarkCommand.java
``` java
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";
    public static final String COMMAND_FORMAT = "mark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s\n";
    public static final String MESSAGE_MARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final List<TaskIndex> targetIndices;

    private List<ReadOnlyTask> lastShownEventList;
    private List<ReadOnlyTask> lastShownFloatingList;
    private final LinkedList<Integer> targettedEventIndices;
    private final LinkedList<Integer> targettedTaskIndices;
    private final LinkedList<Task> eventsToMark;
    private final LinkedList<Task> tasksToMark;

    private final StringBuilder resultSb = new StringBuilder();
    private String addMessage = StringUtil.EMPTY_STRING;
    private int numOfSuccessfulMark = 0;

    public MarkCommand(List<TaskIndex> indiceslist) {
        this.targetIndices = indiceslist;
        this.targettedEventIndices = new LinkedList<Integer>();
        this.targettedTaskIndices = new LinkedList<Integer>();
        this.eventsToMark = new LinkedList<Task>();
        this.tasksToMark = new LinkedList<Task>();
    }

    @Override
    public CommandResult execute() throws CommandException {
        lastShownEventList = model.getFilteredTaskList(TaskType.EVENT);
        lastShownFloatingList = model.getFilteredTaskList(TaskType.FLOATING);
        for (TaskIndex targetIndex : targetIndices) {
            int filteredTaskListIndex = targetIndex.getIndex() - 1;
            if (targetIndex.getTaskType().equals(TaskType.EVENT)) {
                if (filteredTaskListIndex >= lastShownEventList.size() || filteredTaskListIndex < 0) {
                    return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
                }
                targettedEventIndices.add(targetIndex.getIndex());
                eventsToMark.add((Task) lastShownEventList.get(filteredTaskListIndex));
            } else {
                if (filteredTaskListIndex >= lastShownFloatingList.size() || filteredTaskListIndex < 0) {
                    return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
                }
                targettedTaskIndices.add(targetIndex.getIndex());
                tasksToMark.add((Task) lastShownFloatingList.get(filteredTaskListIndex));
            }
        }

        this.markTasks();

        return new CommandResult(resultSb.toString());
    }

    /**
     * mark tasks according to tasks or events
     */
    private void markTasks() throws CommandException {
        int numOfSuccessfulMark = 0;
        numOfSuccessfulMark += markTasks(tasksToMark, targettedTaskIndices);
        numOfSuccessfulMark += markTasks(eventsToMark, targettedEventIndices);
        if (numOfSuccessfulMark > 0) {
            model.recordMark(numOfSuccessfulMark);
        }
    }

    /**
     * @return number of successful mark count
     */
    private int markTasks(LinkedList<Task> tasksToMark, LinkedList<Integer> targettedIndices) throws CommandException {
        try {
            for (Task taskToMark : tasksToMark) {
                if (taskToMark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_MARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulMark++;
                    taskToMark = new Task(taskToMark);
                    taskToMark.setStatus(new Status(true));
                    Recurrence recur = taskToMark.getRecurrence();
                    taskToMark.setRecurrence(new Recurrence(Recurrence.DEFAULT_VALUES));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToMark);
                    taskToMark = addNewRecurTask(taskToMark, recur);
                    resultSb.append(String.format(MESSAGE_MARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }

            resultSb.append(addMessage);
        } catch (DuplicateTaskException e) {
            //ignore for completed
        } catch (IllegalValueException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
        return numOfSuccessfulMark;
    }

    /**
     * add new Recurring Task
     */
    private Task addNewRecurTask(Task taskToMark, Recurrence recurrence) throws IllegalValueException {
        Task toAdd;
        int times = recurrence.occurences;

        if (recurrence.type != Recurrence.Type.None && (times >= 0)) {
            numOfSuccessfulMark++;
            String start = DateTimeUtil.getRecurDate(taskToMark.getDateTime().startValue, recurrence.type.name());
            String end = DateTimeUtil.getRecurDate(taskToMark.getDateTime().endValue, recurrence.type.name());

            toAdd = new Task(
                    taskToMark.getName(),
                    taskToMark.getPriority(),
                    taskToMark.getDescription(),
                    taskToMark.getLocation(),
                    taskToMark.getCategories(),
                    new DateTime(start, end),
                    new Recurrence(Recurrence.DEFAULT_VALUES));

            toAdd.setStatus(new Status());

            if (times == 1) {
                toAdd.setRecurrence(new Recurrence(Recurrence.DEFAULT_VALUES));
            } else if (times > 1) {
                String[] newRecurValues = { recurrence.type.name(), Integer.toString(times - 1) };
                toAdd.setRecurrence(new Recurrence(newRecurValues));
            } else {
                toAdd.setRecurrence(taskToMark.getRecurrence());
            }

            model.addTask(toAdd);

            String conflictingTaskList = model.getTaskConflictingDateTimeWarningMessage(toAdd.getDateTime());
            addMessage = String.format(messageSummary(conflictingTaskList), toAdd);
        }

        return taskToMark;
    }

    /**
     * Method for conflicting tasks
     * @param conflictingTaskList
     * @return messageSummary
     */
    private String messageSummary(String conflictingTaskList) {
        String summary = StringUtil.EMPTY_STRING;
        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.SYSTEM_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }
        return summary;
    }
}
```
###### \java\savvytodo\logic\commands\UnmarkCommand.java
``` java
public class UnmarkCommand extends Command {

    public static final String COMMAND_WORD = "unmark";
    public static final String COMMAND_FORMAT = "unmark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the marked tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s\n";
    public static final String MESSAGE_UNMARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final List<TaskIndex> targetIndices;

    private List<ReadOnlyTask> lastShownEventList;
    private List<ReadOnlyTask> lastShownFloatingList;
    private final LinkedList<Integer> targettedEventIndices;
    private final LinkedList<Integer> targettedTaskIndices;
    private final LinkedList<Task> eventsToUnmark;
    private final LinkedList<Task> tasksToUnmark;

    private final StringBuilder resultSb = new StringBuilder();

    public UnmarkCommand(List<TaskIndex> indicesList) {
        this.targetIndices = indicesList;
        this.targettedEventIndices = new LinkedList<Integer>();
        this.targettedTaskIndices = new LinkedList<Integer>();
        this.eventsToUnmark = new LinkedList<Task>();
        this.tasksToUnmark = new LinkedList<Task>();
    }

    @Override
    public CommandResult execute()  throws CommandException {
        for (TaskIndex targetIndex : targetIndices) {
            lastShownEventList = model.getFilteredTaskList(TaskType.EVENT);
            lastShownFloatingList = model.getFilteredTaskList(TaskType.FLOATING);
            int filteredTaskListIndex = targetIndex.getIndex() - 1;
            if (targetIndex.getTaskType().equals(TaskType.EVENT)) {
                if (filteredTaskListIndex >= lastShownEventList.size() || filteredTaskListIndex < 0) {
                    return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
                }
                targettedEventIndices.add(targetIndex.getIndex());
                eventsToUnmark.add((Task) lastShownEventList.get(filteredTaskListIndex));
            } else {
                if (filteredTaskListIndex >= lastShownFloatingList.size() || filteredTaskListIndex < 0) {
                    return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
                }
                targettedTaskIndices.add(targetIndex.getIndex());
                tasksToUnmark.add((Task) lastShownFloatingList.get(filteredTaskListIndex));
            }
        }

        this.unmarkTasks();

        return new CommandResult(resultSb.toString());
    }

    /**
     * unmark tasks according to tasks or events
     */
    private void unmarkTasks() {
        int numOfSuccessfulUnmark = 0;
        numOfSuccessfulUnmark += unmarkTasks(tasksToUnmark, targettedTaskIndices);
        numOfSuccessfulUnmark += unmarkTasks(eventsToUnmark, targettedEventIndices);

        if (numOfSuccessfulUnmark > 0) {
            model.recordMark(numOfSuccessfulUnmark);
        }
    }

    /**
     * @return number of successful unmark count
     */
    private int unmarkTasks(LinkedList<Task> tasksToUnmark, LinkedList<Integer> targettedIndices) {
        int numOfSuccessfulUnmark = 0;
        try {
            for (Task taskToUnmark : tasksToUnmark) {
                if (!taskToUnmark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulUnmark++;
                    taskToUnmark = new Task(taskToUnmark);
                    taskToUnmark.setStatus(new Status(false));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToUnmark);
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }
        } catch (DuplicateTaskException e) {
            //ignore for completed
        }
        return numOfSuccessfulUnmark;
    }

}
```
###### \java\savvytodo\logic\parser\AddCommandParser.java
``` java
/**
 * @author A0140016B
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_PRIORITY, PREFIX_DATE_TIME,
                PREFIX_RECURRENCE, PREFIX_DESCRIPTION, PREFIX_LOCATION, PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);

        try {

            return new AddCommand(argsTokenizer.getPreamble().get(),
                    argsTokenizer.getValue(PREFIX_PRIORITY).orElse(Priority.Level.Medium.toString()),
                    argsTokenizer.getValue(PREFIX_DESCRIPTION).orElse(Description.DESCRIPTION_DEFAULT_VALUES),
                    argsTokenizer.getValue(PREFIX_LOCATION).orElse(Location.LOCATION_DEFAULT_VALUES),
                    ParserUtil.getDateTimeFromArgs(argsTokenizer.getValue(PREFIX_DATE_TIME)),
                    ParserUtil.getRecurrenceFromArgs(argsTokenizer.getValue(PREFIX_RECURRENCE)),
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_CATEGORY)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\savvytodo\logic\parser\MarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class MarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<List<TaskIndex>> indicesList = ParserUtil.parseMultipleInteger(args);
        if (!indicesList.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
        return new MarkCommand(indicesList.get());
    }

}
```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * @param listIdentifier
     * @return true is it has valid floating task type
     */
    private static boolean isValidTaskType(String listIdentifier) {
        return listIdentifier.equalsIgnoreCase(CliSyntax.INDEX_FLOATING);
    }

    /**
     * @param unfilteredIndexString that is not a integer, it cannot be null
     * @return position character of the String is there is any
     */
    private static String listIdentifier(String unfilteredIndexString) {
        String listIdentifier = StringUtil.EMPTY_STRING + unfilteredIndexString.charAt(CHAR_POS_0);
        return listIdentifier;
    }

    /**
     * Returns List<TaskIndex> if the String is parsed
     * Returns a List<TaskIndex> populated by all elements in the given string
     * Returns a List<TaskIndex> if the given {@code Optional} is empty,
     * or if the List<TaskIndex> contained in the {@code Optional} is empty
     */
    public static Optional<List<TaskIndex>> parseMultipleInteger(String indicesString) {
        boolean parseError = false;

        String trimmedIndicesString = indicesString.trim();
        String[] indicesArray = trimmedIndicesString.split(StringUtil.WHITESPACE_REGEX);
        List<TaskIndex> indicesList = new ArrayList<TaskIndex>();

        if (!trimmedIndicesString.isEmpty()) {
            for (String index : indicesArray) {
                String listIdentifier = listIdentifier(index);
                if (!StringUtil.isUnsignedInteger(index)) {
                    if (isValidTaskType(listIdentifier)) {
                        index = index.substring(1);
                        if (!StringUtil.isUnsignedInteger(index)) {
                            parseError = true;
                            break;
                        } else {
                            indicesList.add(new TaskIndex(TaskType.FLOATING, Integer.parseInt(index)));
                        }
                    } else {
                        parseError = true;
                        break;
                    }
                } else {
                    indicesList.add(new TaskIndex(TaskType.EVENT, Integer.parseInt(index)));
                }
            }
        }

        if (indicesList.isEmpty() || parseError) {
            return Optional.empty();
        }
        return Optional.of(indicesList);
    }
```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Extract a {@code Optional<String> dateTime} into an {@code String[]} if {@code dateTime} is present.
     * @throws IllegalValueException for invalid dateTime
     */
    public static String[] getDateTimeFromArgs(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return new String[] {StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]};
            } else {
                return dateTimeValues;
            }
        } else {
            return DateTime.DEFAULT_VALUES;
        }
    }

    /**
     * Extract a {@code Optional<String> recurrence} into an {@code String[]} if {@code recurrence} is present.
     */
    public static String[] getRecurrenceFromArgs(Optional<String> recurrence) {
        assert recurrence != null;
        return recurrence.isPresent() ? recurrence.get().split(StringUtil.WHITESPACE_REGEX) : Recurrence.DEFAULT_VALUES;
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> priority} into an {@code Optional<Priority>} if {@code priority} is present.
     */
    public static Optional<Priority> parsePriority(Optional<String> priority) throws IllegalValueException {
        assert priority != null;
        return priority.isPresent() ? Optional.of(new Priority(priority.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> location} into an {@code Optional<Location>} if {@code location} is present.
     */
    public static Optional<Location> parseLocation(Optional<String> location) throws IllegalValueException {
        assert location != null;
        return location.isPresent() ? Optional.of(new Location(location.get())) : Optional.empty();
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> dateTime} into an {@code Optional<DateTime>}
     * if {@code dateTime} is present.
     */
    public static Optional<DateTime> parseDateTime(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return Optional.of(new DateTime(StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]));
            } else {
                return Optional.of(new DateTime(dateTimeValues[ARRAY_FIELD_1], dateTimeValues[ARRAY_FIELD_2]));
            }
        } else {
            return Optional.empty();
        }
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> recurrence} into an {@code Optional<Recurrence>}
     * if {@code recurrence} is present.
     */
    public static Optional<Recurrence> parseRecurrence(Optional<String> recurrence) throws IllegalValueException {
        assert recurrence != null;
        if (recurrence.isPresent()) {
            String [] recurValues = recurrence.get().split(StringUtil.WHITESPACE_REGEX);
            if (recurValues.length == 2) {
                if (!StringUtil.isUnsignedInteger(recurValues[ARRAY_FIELD_2])) {
                    throw new IllegalValueException(Recurrence.MESSAGE_INVALID_RECUR_NUM);
                }
                return Optional
                        .of(new Recurrence(recurValues[ARRAY_FIELD_1], Integer.parseInt(recurValues[ARRAY_FIELD_2])));
            } else if (recurValues.length == 1) {
                return Optional
                        .of(new Recurrence(recurValues[ARRAY_FIELD_1],
                                Integer.parseInt(Recurrence.DEFAULT_VALUES[ARRAY_FIELD_2])));
            }
            throw new IllegalValueException(Recurrence.MESSAGE_RECURR_CONSTRAINTS);
        } else {
            return Optional.empty();
        }
    }
```
###### \java\savvytodo\logic\parser\UnmarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UnmarkCommand object
 */
public class UnmarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the UnmarkCommand
     * and returns an UnmarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<List<TaskIndex>> indicesList = ParserUtil.parseMultipleInteger(args);
        if (!indicesList.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }
        return new UnmarkCommand(indicesList.get());
    }

}
```
###### \java\savvytodo\model\Model.java
``` java
    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    ObservableList<ReadOnlyTask> getFilteredTaskList();

```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * @author A0140016B
     * Returns a string of conflicting datetimes within a specified datetime
     * @throws IllegalValueException
     * @throws DateTimeException
     */
    public String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck)
            throws DateTimeException, IllegalValueException {
        StringBuilder conflictingTasksStringBuilder = new StringBuilder(StringUtil.EMPTY_STRING);

        if (dateTimeToCheck.endValue == StringUtil.EMPTY_STRING) {
            return StringUtil.EMPTY_STRING;
        }

        appendConflictingTasks(conflictingTasksStringBuilder, dateTimeToCheck);

        return conflictingTasksStringBuilder.toString();
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * @param conflictingTasksStringBuilder to generate conflicting tasks in String
     * @return number of task conflicted
     */
    private int appendConflictingTasks(
            StringBuilder conflictingTasksStringBuilder,
            DateTime dateTimeToCheck) throws DateTimeException, IllegalValueException {
        int conflictCount = 0;
        int conflictPosition = 1;
        for (ReadOnlyTask task : filteredEventTasks) {
            if (task.isCompleted().value == Status.ONGOING
                    && DateTimeUtil.isDateTimeConflict(task.getDateTime(), dateTimeToCheck)) {
                conflictingTasksStringBuilder
                        .append(String.format(TASK_CONFLICTED, conflictPosition, task.getAsText()));
                conflictCount++;
            }
            conflictPosition++;
        }
        return conflictCount;
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return taskManager.getTaskList();
    }
```
###### \java\savvytodo\model\ModelManager.java
``` java
    public void updateFilteredTaskListByDateTime(DateTime dateTime) {
        updateFilteredTaskList(new PredicateExpression(new DateTimeQualifier(dateTime)));
    }
```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * Qualifier to sort by DateTime specified
     * Task type must be event
     */
    private class DateTimeQualifier implements Qualifier {

        private LocalDateTime startDateTime;
        private LocalDateTime endDateTime;
        private DateTime dateTimeQuery;

        public DateTimeQualifier (DateTime dateTime) {
            if (dateTime.getStartDate() != null) {
                startDateTime = DateTimeUtil.setLocalTime(dateTime.getStartDate(),
                        DateTimeUtil.FIRST_HOUR_OF_DAY,
                        DateTimeUtil.FIRST_MINUTE_OF_DAY,
                        DateTimeUtil.FIRST_SECOND_OF_DAY);
                endDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.LAST_HOUR_OF_DAY,
                        DateTimeUtil.LAST_MINUTE_OF_DAY,
                        DateTimeUtil.LAST_SECOND_OF_DAY);
            } else {
                startDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.FIRST_HOUR_OF_DAY,
                        DateTimeUtil.FIRST_MINUTE_OF_DAY,
                        DateTimeUtil.FIRST_SECOND_OF_DAY);
                endDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.LAST_HOUR_OF_DAY,
                        DateTimeUtil.LAST_MINUTE_OF_DAY,
                        DateTimeUtil.LAST_SECOND_OF_DAY);
            }

            try {
                dateTimeQuery = new DateTime();
                dateTimeQuery.setStart(startDateTime);
                dateTimeQuery.setEnd(endDateTime);
            } catch (IllegalValueException e) {
                dateTimeQuery = new DateTime(LocalDateTime.now(), LocalDateTime.now());
                e.printStackTrace();
            }
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            try {
                return DateTimeUtil.isDateTimeWithinRange(task.getDateTime(), dateTimeQuery);
            } catch (DateTimeException e) {
                e.printStackTrace();
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
            return false;
        }
    }

}
```
###### \java\savvytodo\model\task\Priority.java
``` java
/**
 * Represents a Task's priority in the task manager
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be 'low(1)', 'medium(2)' "
            + "or 'high(3)'\n Example: p/3 , p/h or p/high means the HIGH priority";

    private static final int COMPARE_TO_SMALLER = -1;
    private static final int COMPARE_TO_EQUAL = 0;
    private static final int COMPARE_TO_GREATER = 1;

```
###### \java\savvytodo\model\task\Priority.java
``` java
    /**
     * @author A0140016B
     * Get type enum object from it's name, ignoring cases
     * @param String recurrence type
     * @return Corresponding enum object
     */
    public enum Level {
        Low(1),
        Medium(2),
        High(3);

        private Integer value;

        Level(int value) {
            this.value = value;
        }

        int showInt() {
            return value;
        }
    }

    public final String value;
    private int level;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }

        if (!StringUtil.isUnsignedInteger(priority)) {
            this.value = this.mapValue(priority);
        } else {
            this.value = mapLevel(priority);
        }
    }

    /**
     * @return String priority map and assign value if is String
     */
    private String mapValue(String priority) {
        String val = Level.Medium.toString();
        for (Level level : Level.values()) {
            if (level.toString().substring(0, 1).equalsIgnoreCase(priority)
                    || level.toString().equalsIgnoreCase(priority)) {
                this.level = level.ordinal();
                val = level.toString();
            }
        }

        return val;
    }

    /**
     * @return String priority map and assign value if is integer
     */
    private String mapLevel(String priority) {
        String val = Level.Medium.toString();
        for (Level level : Level.values()) {
            if (Integer.toString(level.showInt()).equalsIgnoreCase(priority)) {
                this.level = level.ordinal();
                val = level.toString();
            }
        }

        return val;
    }

    public static String getPriorityValue(String priority) {
        for (Level level : Level.values()) {
            if (level.toString().substring(0, 1).equalsIgnoreCase(priority)) {
                return level.toString();
            }
        }

        return Level.Medium.toString();
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        boolean matches = false;
        for (Level level : Level.values()) {
            if (level.toString().equalsIgnoreCase(test) || Integer.toString(level.showInt()).equalsIgnoreCase(test)
                    || isValidCharPriority(level, test)) {
                matches = true;
            }
        }
        return matches;
    }

    /**
     * Return true if string matches first char
     */
    private static boolean isValidCharPriority(Level level, String test) {
        return level.toString().substring(0, 1).equalsIgnoreCase(test);
    }

```
###### \java\savvytodo\model\task\Priority.java
``` java
    @Override
    public int compareTo(Priority o) {
        if (this.level > o.level) {
            return COMPARE_TO_GREATER;
        } else if (this.level < o.level) {
            return COMPARE_TO_SMALLER;
        } else {
            return COMPARE_TO_EQUAL;
        }
    }

}
```
###### \java\savvytodo\model\task\ReadOnlyTask.java
``` java
/**
 * @author A0140016B
 * A read-only immutable interface for a Task in the taskManager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();
    Priority getPriority();
    Description getDescription();
    Location getLocation();
    DateTime getDateTime();
    Recurrence getRecurrence();
    Status isCompleted();
    Type getType();
    TimeStamp getTimeStamp();

    /**
     * The returned CategoryList is a deep copy of the internal CategoryList,
     * changes on the returned list will not affect the task's internal categories.
     */
    UniqueCategoryList getCategories();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getPriority().equals(this.getPriority())
                && other.isCompleted().equals(this.isCompleted())
                && other.getDescription().equals(this.getDescription())
                && other.getDateTime().equals(this.getDateTime())
                && other.getLocation().equals(this.getLocation()))
                && other.isCompleted().equals(this.isCompleted())
                && other.getType().equals(this.getType());
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
                .append(" Type: ")
                .append(getType())
                .append(" Date Time: ")
                .append(getDateTime())
                .append(" Recurrence: ")
                .append(getRecurrence())
                .append(" Priority: ")
                .append(getPriority())
                .append(" Location: ")
                .append(getLocation())
                .append(" Description: ")
                .append(getDescription())
                .append(" Status: ")
                .append(isCompleted())
                .append(" Categories: ");
        getCategories().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\savvytodo\model\task\Recurrence.java
``` java
/**
 * @author A0140016B
 *
 * Represents Task's Recurrence in the task manager Guarantees: immutable;
 * is valid as declared in {@link #isValidRecurrence(String, int)} *
 */
public class Recurrence implements Comparable<Recurrence> {

    /**
     * @author A0140016B
     *
     * Specifies the type of recurrence for the task
     * Defaults to none if it is a one-time task
     */
    public enum Type {
        None, Daily, Weekly, Monthly, Yearly;

        /**
         * Get type enum object from it's name, ignoring cases
         * @param String recurrence type
         * @return Corresponding enum object
         * @throws IllegalArgumentException if invalid input
         */
        public static Type valueOfIgnoreCase(String reType) {
            for (Type type : Type.values()) {
                if (type.toString().equalsIgnoreCase(reType)
                        || type.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                    return type;
                }
            }
            throw new IllegalArgumentException(MESSAGE_RECURR_NOT_MATCH);
        }

        /**
         * Compare enum object with String to see if it matches whole string or first char
         * @param String retype cannot be null
         * @return boolean of whether string matches enum object
         */
        public static boolean matches(String reType) {
            for (Type type : Type.values()) {
                if (type.toString().equalsIgnoreCase(reType)
                        || type.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Compare enum object with String to see if it matches
         * @param String retype cannot be null
         * @return boolean of wheather string matches enum object
         */
        public static boolean isNone(String reType) {
            if (Type.None.toString().equalsIgnoreCase(reType)
                    || Type.None.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                return true;
            } else {
                return false;
            }
        }

    }

    public int occurences;
    public Type type;

    public static final String MESSAGE_RECURR_CONSTRAINTS = "Recurrence Parameters accepted: r/TYPE [NUM OF TIMES] \n"
            + "with [NUM OF TIMES] = 0 if not specified AND If recurrence type is NONE, occurences can only be 0!\n"
            + "Else for other type, if occurences is 0 => forever recurring!\n"
            + "Some examples: r/w 2, r/daily 3, r/n 0";
    public static final String MESSAGE_RECURR_NOT_MATCH =
            "Task recurrence type should be 'none', 'daily', 'weekly', 'monthly' or 'yearly'";
    public static final String MESSAGE_INVALID_RECUR_NUM = "Number of recurrence provided is invalid!";
    public static final String[] DEFAULT_VALUES = {Type.None.toString(), "0"};

    /**
     * Default constructor
     * @throws IllegalValueException
     * @throws NumberFormatException
     */
    public Recurrence() throws IllegalValueException {
        this(DEFAULT_VALUES);
    }

    /**
     * Validates given Recurrence.
     * @throws IllegalValueException if given Recurrence is invalid.
     */
    public Recurrence(String type, int occurences) throws IllegalValueException {
        assert type != null;
        String trimmedType = type.trim();
        if (!Type.matches(type)) {
            throw new IllegalValueException(MESSAGE_RECURR_NOT_MATCH);
        }
        if (!isValidRecurrence(trimmedType, occurences)) {
            throw new IllegalValueException(MESSAGE_RECURR_CONSTRAINTS);
        }
        this.type = Type.valueOfIgnoreCase(trimmedType);
        this.occurences = occurences;
    }

    /**
     * Constructor when given input as String array
     * @param recurrence string array
     * @throws IllegalValueException
     * @throws NumberFormatException
     */
    public Recurrence(String[] recurrence) throws NumberFormatException, IllegalValueException {
        this(recurrence[0], Integer.parseInt(recurrence[1]));
    }

    /**
     * Returns true if a given string is a valid task Recurrence and num is more than -1.
     */
    public static boolean isValidRecurrence(String type, int numOfTimes) {
        if (numOfTimes >= 0 && Type.matches(type)) {
            if (Type.isNone(type) && numOfTimes != 0) {
                return false;
            } else {
                return true;
            }
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        return this.type.toString() + " (" + this.occurences + " more times)";
    }

```
###### \java\savvytodo\model\task\Task.java
``` java
/**
 * @author A0140016B
 * Represents a Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask, Comparable<Task> {

    private Name name;
    private Priority priority;
    private Description description;
    private Location location;
    private DateTime dateTime;
    private Recurrence recurrence;
    private Status isCompleted;
    private TimeStamp timeStamp;
    private Type type;

    private UniqueCategoryList categories;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories,
                dateTime, recurrence);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = new Status();
        this.type = new Type(dateTime);
        this.timeStamp = new TimeStamp();
    }

    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence,
            TimeStamp timeStamp) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories,
                dateTime, recurrence, timeStamp);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = new Status();
        this.type = new Type(dateTime);
        this.timeStamp = new TimeStamp(timeStamp);
    }

    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence, Status status,
            TimeStamp timeStamp) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories,
                dateTime, recurrence, status);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = status;
        this.type = new Type(dateTime);
        this.timeStamp = new TimeStamp(timeStamp);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPriority(), source.getDescription(), source.getLocation(),
                source.getCategories(), source.getDateTime(), source.getRecurrence(),
                source.isCompleted(), source.getTimeStamp());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    public void setLocation(Location location) {
        assert location != null;
        this.location = location;
    }

    @Override
    public Location getLocation() {
        return location;
    }

    public void setDateTime(DateTime dateTime) {
        assert dateTime != null;
        this.dateTime = dateTime;
        updateType();
    }

    @Override
    public DateTime getDateTime() {
        return dateTime;
    }

    public void setRecurrence(Recurrence recurrence) {
        assert recurrence != null;
        this.recurrence = recurrence;
    }

    @Override
    public Recurrence getRecurrence() {
        return recurrence;
    }

    @Override
    public Status isCompleted() {
        assert isCompleted != null;
        return isCompleted;
    }

    public void setStatus(Status isCompleted) {
        this.isCompleted = isCompleted;
    }

    @Override
    public UniqueCategoryList getCategories() {
        return new UniqueCategoryList(categories);
    }

    /**
     * Replaces this task's categories with the categories in the argument category list.
     */
    public void setCategories(UniqueCategoryList replacement) {
        categories.setCategories(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setDescription(replacement.getDescription());
        this.setLocation(replacement.getLocation());
        this.setCategories(replacement.getCategories());
        this.setDateTime(replacement.getDateTime());
        this.setRecurrence(replacement.getRecurrence());
        this.setStatus(replacement.isCompleted());
        this.setType(replacement.getType());
        this.setTimeStamp(replacement.getTimeStamp());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, priority, description, location, categories, dateTime, recurrence,
                isCompleted, timeStamp);
    }

    @Override
    public String toString() {
        return getAsText();
    }

```
###### \java\savvytodo\model\task\UniqueTaskList.java
``` java
    /**
     * @return ObservableList<Task> for sorting purpose
     */
    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * Moves the task to the new corresponding list (if it switches between floating and event)
     * {@code TaskManager}'s category list will be updated with the categorys of {@code editedReadOnlyTask}.
     * @see #syncMasterCategoryListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterCategoryListWith(editedTask);
        // TODO: the categorys master list will be updated even though the below line fails.
        // This can cause the categorys master list to have additional categorys that are not categoryged to any task
        // in the task list.

        tasks.updateTask(index, editedTask); //global task list storage
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by ascending priority - Low to High
     */
    public void sortByAscendingPriority() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o1.getPriority().compareTo(o2.getPriority());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by descending priority - High to Low
     */
    public void sortByDescendingPriority() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o2.getPriority().compareTo(o1.getPriority());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by ascending end dateTime
     */
    public void sortByAscendingDatetime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o1.getDateTime().compareTo(o2.getDateTime());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by descending end dateTime
     */
    public void sortByDescendingDatetime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o2.getDateTime().compareTo(o1.getDateTime());
            }
        });
    }
```
###### \java\savvytodo\ui\TaskCard.java
``` java
public class TaskCard extends UiPart<Region> {

    private static final String FXML = "TaskListCard.fxml";

    private static final String LABEL_LOW = "L";
    private static final String LABEL_MEDIUM = "M";
    private static final String LABEL_HIGH = "H";
    private static final String LABEL_DONE = "✔ ";

    private static final String PRIORITY_LOW = "Low";
    private static final String PRIORITY_MEDIUM = "Medium";
    private static final String PRIORITY_HIGH = "High";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label status;
    @FXML
    private Label priority;
    @FXML
    private Label dateTime;
    @FXML
    private Label description;
    @FXML
    private FlowPane categories;
    @FXML
    private Circle circle;


    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        name.setText(task.getName().name);
        setId(task, displayedIndex);
        description.setText(task.getDescription().value);
        dateTime.setText(getDateTimeRecur(task));
        setStatus(task);
        initCategories(task);
        setCircle(task);
    }

```
###### \java\savvytodo\ui\TaskCard.java
``` java
    private void setStatus(ReadOnlyTask task) {
        if (task.isCompleted().value == Status.COMPLETED) {
            status.setText(LABEL_DONE + task.isCompleted().toString());
        }
    }

    private void setCircle(ReadOnlyTask task) {
        switch (task.getPriority().value) {
        case PRIORITY_HIGH:
            priority.setText(LABEL_HIGH);
            circle.setFill(Color.RED);
            break;
        case PRIORITY_MEDIUM:
            priority.setText(LABEL_MEDIUM);
            circle.setFill(Color.ORANGE);
            break;
        case PRIORITY_LOW:
            priority.setText(LABEL_LOW);
            circle.setFill(Color.GREENYELLOW);
            break;
        default:
            break;
        }
    }

    private String getDateTimeRecur(ReadOnlyTask task) {
        StringBuilder sb = new StringBuilder();
        if (task.getType().getType() == TaskType.FLOATING) {
            sb.append("-");
        } else if (task.getType().getType() == TaskType.DEADLINE) {
            sb.append("Due By: " + task.getDateTime().toString());
        } else {
            sb.append(task.getDateTime().toString());
            if (!task.getRecurrence().type.name().equalsIgnoreCase(Recurrence.Type.None.name())) {
                if (task.getRecurrence().occurences > 0) {
                    sb.append(StringUtil.WHITESPACE + "[" + task.getRecurrence().toString() + "]");
                } else {
                    sb.append(StringUtil.WHITESPACE + "[" + task.getRecurrence().type.name() + "]");
                }
            }
        }

        return sb.toString();
    }

    private void initCategories(ReadOnlyTask task) {
        task.getCategories().forEach(category -> categories.getChildren().add(new Label(category.categoryName)));
    }
}
```
###### \resources\view\DarkTheme.css
``` css
.background {
    -fx-background-color: derive(#146f77, 20%);
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}
```
###### \resources\view\DarkTheme.css
``` css
#categories {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#categories .label {
    -fx-text-fill: white;
    -fx-background-color: #0f5e66;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}

#dateTime {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
    -fx-font-style: italic;
}

#id {
    -fx-font-size: 18px;
  	-fx-font-family: "Tahoma";
    -fx-fill: #00e7ff;
    -fx-effect: innershadow( three-pass-box , rgba(0.0,0.0,0.0,0.7) , 6.0, 0.0 , 0.0 , 2.0 );
}

#priority {
	-fx-padding: 2 0 0 0;
	-fx-font-weight: bold;
	-fx-font-size: 16px;
	-fx-text-fill: white;
}
```
###### \resources\view\TaskListCard.fxml
``` fxml

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" minHeight="105.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>

                    <children>
                        <HBox spacing="5" alignment="CENTER_LEFT">
                            <children>
                                <HBox>
                                    <Label fx:id="id"  minWidth="-Infinity" />
                                    <Label fx:id="name" styleClass="cell_big_label" text="\$name" wrapText="true" />
                                </HBox>
								<StackPane>
									<Circle fx:id="circle" fill="WHITE" radius="11.0"
										stroke="BLACK" strokeType="INSIDE" strokeWidth="0.0">
									</Circle>
									<Label fx:id="priority" alignment="CENTER"
										contentDisplay="CENTER"	textAlignment="CENTER" textFill="WHITE">
										<font>
											<Font size="11.0" />
										</font>
									</Label>
								</StackPane>
                            </children>
                        </HBox>
                        <FlowPane fx:id="categories" prefWrapLength="10.0" />
						<Label fx:id="status" styleClass="cell_small_label" />
                        <Label fx:id="dateTime" />
                        <Label fx:id="description" styleClass="cell_small_label" />
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
