# A0140016B
###### \java\savvytodo\commons\util\DateTimeUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to DateTime
 */
public class DateTimeUtil {

    private static final String TIME_ONLY_FORMAT = "HHmm";
    private static final String DATE_ONLY_FORMAT = "dd/MM/uuuu";
    private static final String DATE_FORMAT = "d/M/uuuu HHmm";
    private static final String DATE_STRING_FORMAT = "dd/MM/uuuu HHmm";

    public static final int FIRST_HOUR_OF_DAY = 0;
    public static final int FIRST_MINUTE_OF_DAY = 0;
    public static final int FIRST_SECOND_OF_DAY = 0;
    public static final int LAST_HOUR_OF_DAY = 23;
    public static final int LAST_MINUTE_OF_DAY = 59;
    public static final int LAST_SECOND_OF_DAY = 59;

    private static final String DAILY = "daily";
    private static final String WEEKLY = "weekly";
    private static final String MONTHLY = "monthly";
    private static final String YEARLY = "yearly";
    private static final int INCREMENT_FREQ = 1;

    private static final DateTimeFormatter DATE_ONLY_FORMATTER = DateTimeFormatter.ofPattern(DATE_ONLY_FORMAT);
    private static final DateTimeFormatter TIME_ONLY_FORMATTER = DateTimeFormatter.ofPattern(TIME_ONLY_FORMAT);

    public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT)
            .withResolverStyle(ResolverStyle.STRICT);
    public static final DateTimeFormatter DATE_STRING_FORMATTER = DateTimeFormatter.ofPattern(DATE_STRING_FORMAT);

    public static final String MESSAGE_INCORRECT_SYNTAX = "It must be a valid date";

    private static final String MESSAGE_DURATION = "%1$s hr %2$s min";

    public static final String MESSAGE_FREE_TIME_SLOT = StringUtil.SYSTEM_NEWLINE + "%1$s. %2$shrs to %3$shrs (%4$s)";


    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return String[] with first index being the start DateTime and second index being the end
     *         date Time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) {
        return NattyDateTimeParserUtil.parseStringToDateTime(dateTimeArgs);
    }

    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return LocalDateTime
     */
    private static LocalDateTime parseStringToLocalDateTime(String dateTime) {
        return LocalDateTime.parse(dateTime, DATE_FORMATTER);
    }

    /**
     * Checks if given endDateTime is within today and the end of this week
     */
    public static boolean isWithinWeek(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime endThisWeek = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)).withHour(0).withMinute(0)
                    .withSecond(0);
            return endDateTime.isAfter(now) && endDateTime.isBefore(endThisWeek);
        }
    }

    /**
     * Checks if given event's endDateTime is before the end of today
     */
    public static boolean isOverDue(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            return endDateTime.isBefore(now);
        }
    }

    /**
     * Checks whether the dateTimeQuery falls within the range of the dateTimeSource
     * i.e. dateTimeQuery start is equals to or before the dateTimeSource end
     * && dateTimeQuery end is equals to or after the dateTimeSource start
     * Return false if task is a deadline or floating task (i.e. no start or end)
     * @param dateTimeSource
     * @param dateTimeQuery
     * @throws IllegalValueException
     * @throws DateTimeException
     */
    public static boolean isDateTimeWithinRange(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return !dateTimeOriginal.getEndDate().isBefore(dateTimeCompare.getStartDate())
                && !dateTimeOriginal.getStartDate().isAfter(dateTimeCompare.getEndDate());
    }

    /**
     * Checks whether the dateTimeQuery conflicts with the dateTimeSource
     * i.e. dateTimeQuery end should occur after the dateTimeSource start
     * and dateTimeQuery start should occur before the dateTimeSource end
     * Return false if task is a deadline or floating task (i.e. no start or end)
     * @throws IllegalValueException
     * @throws DateTimeException
     */
    public static boolean isDateTimeConflict(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return dateTimeOriginal.getEndDate().isAfter(dateTimeCompare.getStartDate())
                && dateTimeOriginal.getStartDate().isBefore(dateTimeCompare.getEndDate());
    }

    private static DateTime fillDateTime(DateTime filledDateTime) throws IllegalValueException {

        filledDateTime.setEnd(parseStringToLocalDateTime(filledDateTime.endValue));
        filledDateTime.setStart(parseStringToLocalDateTime(filledDateTime.startValue));

        return filledDateTime;
    }

    /**
     * Check whether eventDateTime is an event
     * @param eventDateTime
     * @return whether task is an event
     */
    private static boolean isEvent(DateTime eventDateTime) {
        if (eventDateTime.getStartDate() == null
                || eventDateTime.getEndDate() == null) {
            return false;
        }

        return true;
    }

    /**
     * Check whether dateTimeSource and dateTimeQuery are events before they can be compared
     * @param dateTimeSource
     * @param dateTimeQuery
     * @return whether the task compared to and with are events
     */
    private static boolean areEvents(DateTime dateTimeSource, DateTime dateTimeQuery) {
        if (!isEvent(dateTimeSource)) {
            return false;
        }

        if (!isEvent(dateTimeQuery)) {
            return false;
        }

        return true;
    }

    /**
     * @param dateToCheck cannot be null and it must be an event
     * @return an ArrayList<DateTime> of free slots in a specified date
     * else return an empty ArrayList
     */
    public static ArrayList<DateTime> getListOfFreeTimeSlotsInDate(
            DateTime dateToCheck,
            ArrayList<DateTime> listOfFilledTimeSlotsInDate) {
        ArrayList<DateTime> listOfFreeTimeSlots = new ArrayList<DateTime>();
        if (isEvent(dateToCheck)) {
            LocalDateTime startDateTime = dateToCheck.getStartDate();
            LocalDateTime endDateTime = dateToCheck.getEndDate();

            for (DateTime dateTime : listOfFilledTimeSlotsInDate) {
                if (dateTime.getStartDate() == null) {
                    continue;
                } else {
                    endDateTime = dateTime.getStartDate();
                }

                if (startDateTime.isBefore(endDateTime)) {
                    listOfFreeTimeSlots
                            .add(new DateTime(startDateTime, endDateTime));
                }

                if (startDateTime.isBefore(dateTime.getEndDate())) {
                    startDateTime = dateTime.getEndDate();
                }
            }

            if (startDateTime.isBefore(dateToCheck.getEndDate())) {
                listOfFreeTimeSlots.add(new DateTime(startDateTime, dateToCheck.getEndDate()));
            }
        }

        return listOfFreeTimeSlots;
    }


    public static String getDayAndDateString(DateTime dateTime) {
        StringBuilder sb = new StringBuilder();

        sb.append(dateTime.getEndDate().getDayOfWeek()
                .getDisplayName(TextStyle.FULL, Locale.ENGLISH)).append(",")
                .append(dateTime.getEndDate().format(DATE_ONLY_FORMATTER));

        return sb.toString();
    }

    /**
     * @return String of Free DateTime In Date
     */
    public static String getStringOfFreeDateTimeInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFreeTimeSlotsInDate) {
        StringBuilder sb = new StringBuilder();

        sb.append(getDayAndDateString(dateToCheck))
                .append(":");

        int counter = 1;

        for (DateTime dateTime : listOfFreeTimeSlotsInDate) {
            sb.append(String.format(MESSAGE_FREE_TIME_SLOT, counter,
                    dateTime.getStartDate().format(TIME_ONLY_FORMATTER),
                    dateTime.getEndDate().format(TIME_ONLY_FORMATTER),
                    getDurationBetweenTwoLocalDateTime(dateTime.getStartDate(), dateTime.getEndDate())));
            counter++;
        }

        return sb.toString();
    }

    /**
     * Calculate the duration between 2 dates
     * @param startDateTime is not null
     * @param endDateTime is not null
     * @return String duration between 2 dates
     */
    public static String getDurationBetweenTwoLocalDateTime(
            LocalDateTime startDateTime, LocalDateTime endDateTime) {
        Duration duration = Duration.between(startDateTime, endDateTime);
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;

        return String.format(MESSAGE_DURATION, hours, minutes);
    }

    /**
     * Modify the date based on the new hour, min and sec
     * @return Date
     */
    public static Date setDateTime(Date toBeEdit, int hour, int min, int sec) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(toBeEdit);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, min);
        calendar.set(Calendar.SECOND, sec);
        toBeEdit = calendar.getTime();

        return toBeEdit;
    }

    /**
     * @param recurDate usually is the start date of an event
     * @param freqType is the frequency based on recurrance
     * Modifies the recurDate based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    private static String getRecurDate(String recurDate, String freqType) {
        LocalDateTime date = LocalDateTime.parse(recurDate, DATE_FORMATTER);

        switch (freqType.toLowerCase()) {
        case DAILY:
            date = date.plusDays(INCREMENT_FREQ);
            break;
        case WEEKLY:
            date = date.plusWeeks(INCREMENT_FREQ);
            break;
        case MONTHLY:
            date = date.plusMonths(INCREMENT_FREQ);
            break;
        case YEARLY:
            date = date.plusYears(INCREMENT_FREQ);
            break;
        }

        recurDate = date.format(DATE_STRING_FORMATTER);
        return recurDate;
    }

    /**
     * @param recurDates usually is the start date of an event
     * @param freqType is the frequency based on recurrance
     * @param noOfRecurr is the number of recurrance
     * Modifies the recurDates based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    public static ArrayList<String> getRecurDates(String recurDate, String freqType, int noOfRecurr) {
        ArrayList<String> recurrDates = new ArrayList<String>();

        for (int i = 0; i < noOfRecurr; i++) {
            recurrDates.add(getRecurDate(recurDate, freqType));
        }

        return recurrDates;
    }

    public static LocalDateTime setLocalTime(LocalDateTime dateTime, int hour, int min, int sec) {
        return LocalDateTime.of(dateTime.getYear(), dateTime.getMonth(), dateTime.getDayOfMonth(), hour, min, sec);
    }
}
```
###### \java\savvytodo\commons\util\EnumUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to Enum
 */
public class EnumUtil {
    /**
     * for seed properties
     * @param e
     * @return String []
     */
    public static String[] getNames(Class<? extends Enum<?>> e) {
        return Arrays.stream(e.getEnumConstants()).map(Enum::name).toArray(String[]::new);
    }
}
```
###### \java\savvytodo\commons\util\NattyDateTimeParserUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to NattyDateTimeParser
 */
public class NattyDateTimeParserUtil {

    private static final int EMPTY_GROUP_SIZE = 0;
    private static final int END_DATE_GROUP_SIZE = 1;
    private static final int START_AND_END_DATE_GROUP_SIZE = 2;
    private static final int GROUP_ONE = 0;
    private static final int GROUP_TWO = 1;
    private static final int CHILD_ONE = 0;
    private static final int CHILD_TWO = 1;

    private static final SimpleDateFormat CONVERT_TIME_FORMAT = new SimpleDateFormat("dd/MM/yyyy HHmm");

    private static final String DASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})-(\\d{1,2})";
    private static final String SLASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})/(\\d{1,2})";
    public static final String EQUAL_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})=(\\d{1,2})";
    public static final String EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2}) = (\\d{1,2})";

    private static final String DASH_CONNECTOR_DATE_REPLACEMENT = "$2-$1";
    private static final String SLASH_CONNECTOR_DATE_REPLACEMENT = "$2/$1";
    private static final String WORD_NOW = "NOW";
    private static final String NATTY_EXPLICT_TIME_PREFIX = "EXPLICIT_TIME";

    /**
     * Extracts the new task's dateTime from the string arguments using natty.
     * @param String dateTimeArgs
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) {
        String endDateTime = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String formattedDateTimeArg = convertToUSDateFormat(dateTimeArgs);

        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(formattedDateTimeArg);

        if (isInvalidDateTimeArg(dateTimeArgs, groups)) {
            throw new DateTimeException(Messages.MESSAGE_INVALID_DATETIME);
        }

        if (groups.size() > EMPTY_GROUP_SIZE) {
            DateGroup group = groups.get(GROUP_ONE);
            if (group.getDates().size() == END_DATE_GROUP_SIZE) {
                return retrieveEndDate(group);
            }

            if (group.getDates().size() == START_AND_END_DATE_GROUP_SIZE) {
                return retrieveStartAndEndDate(group);
            }
        }

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Change the date format to US date format.
     * @param unformattedDateTime
     * @return formatted DateTime in US format
     */
    private static String convertToUSDateFormat(String unformattedDateTime) {
        String formattedDateTime = unformattedDateTime.trim()
                .replaceAll(DASH_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(SLASH_CONNECTOR_DATE_FORMAT, SLASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT);
        return formattedDateTime;
    }

    /**
     * Change the date format to Asia date format.
     * @param unformattedDateTime
     * @return formatted DateTime in Asia format
     */
    private static String convertToAsiaDateFormat(Date unformattedDateTime) {
        return CONVERT_TIME_FORMAT.format(unformattedDateTime);
    }

    /**
     * Checks if the DateTime is a invalid format.
     * @return true if the given DateTime is invalid
     */
    private static boolean isInvalidDateTimeArg(String dateTimeArg, List<DateGroup> groups) {
        return (dateTimeArg.trim().length() > 0 && groups.size() == EMPTY_GROUP_SIZE);
    }

    /**
     * Retrieve end date time from natty group for deadlines
     */
    private static String[] retrieveEndDate(DateGroup group) {
        String treeString = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date date;

        treeString = group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();

        date = group.getDates().get(GROUP_ONE);
        if (!isTimePresent(treeString) && !isWordNowPresent(group.getText())) {
            date = DateTimeUtil.setDateTime(date,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        endDateTime = convertToAsiaDateFormat(date);

        return new String[] {StringUtil.EMPTY_STRING, endDateTime};
    }

    /**
     * Retrieve the variables from Natty Parser for events
     */
    private static String[] retrieveStartAndEndDate(DateGroup group) {
        String treeFirstString = StringUtil.EMPTY_STRING;
        String treeSecondString = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date dateOne;
        Date dateTwo;

        treeFirstString =
                group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();
        treeSecondString =
                group.getSyntaxTree().getChild(CHILD_TWO).toStringTree();
        dateOne = group.getDates().get(GROUP_ONE);
        dateTwo = group.getDates().get(GROUP_TWO);

        if (!isTimePresent(treeFirstString) && !isWordNowPresent(group.getText())) {
            dateOne = DateTimeUtil.setDateTime(dateOne,
                    DateTimeUtil.FIRST_HOUR_OF_DAY,
                    DateTimeUtil.FIRST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        if (!isTimePresent(treeSecondString) && !isWordNowPresent(group.getText())) {
            dateTwo = DateTimeUtil.setDateTime(dateTwo,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        startDateTime = CONVERT_TIME_FORMAT.format(dateOne);
        endDateTime = CONVERT_TIME_FORMAT.format(dateTwo);

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Checks if time is present
     * @param treeString
     * @return true if time is present
     */
    private static boolean isTimePresent(String treeString) {
        return treeString.contains(NATTY_EXPLICT_TIME_PREFIX);
    }

    /**
     * Checks if word now is present
     * @param arg
     * @return true if word now is present
     */
    private static boolean isWordNowPresent(String arg) {
        return arg.toLowerCase().contains(WORD_NOW.toLowerCase());
    }
}
```
###### \java\savvytodo\commons\util\StringUtil.java
``` java
    /**
     * @author A0140016B
     * @param string cannot be null
     * @param string Should be trimmed
     * @return string of first character upper case and the rest lower case
     */
    public static String firstCharUpperCaseRestLowerCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1).toLowerCase();
    }

}
```
###### \java\savvytodo\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: NAME [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " "
            + "Project Meeting dt/05/10/2016 1400 = 05/10/2016 1800 r/weekly 2 c/CS2103 "
            + "d/Discuss about roles and milestones";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String priority, String description, String location, String[] dateTime,
            String[] recurrence, Set<String> categories) throws IllegalValueException {
        final Set<Category> categorySet = new HashSet<>();
        for (String categoryName : categories) {
            categorySet.add(new Category(categoryName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Priority(priority),
                new Description(description),
                new Location(location),
                new UniqueCategoryList(categorySet),
                new DateTime(dateTime),
                new Recurrence(recurrence)
        );

        this.toAdd.setStatus(new Status());
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            String conflictingTaskList = model.getTaskConflictingDateTimeWarningMessage(toAdd.getDateTime());
            model.addTask(toAdd);
            return new CommandResult(String.format(messageSummary(conflictingTaskList), toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (DateTimeException e) {
            throw new CommandException(DateTimeUtil.MESSAGE_INCORRECT_SYNTAX);
        } catch (IllegalValueException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }

    /**
     * Method for conflicting tasks
     * @param conflictingTaskList
     * @return messageSummary
     */
    private String messageSummary(String conflictingTaskList) {
        String summary = MESSAGE_SUCCESS;
        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.SYSTEM_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }
        return summary;
    }
}
```
###### \java\savvytodo\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the at least one details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "[NAME] [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " 1 c/CS2103 d/Complete group project component";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final int filteredTaskListIndex;
    private final CommandTaskDescriptor cmdTaskDescriptor;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, CommandTaskDescriptor cmdTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert cmdTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.cmdTaskDescriptor = new CommandTaskDescriptor(cmdTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, cmdTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code cmdTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, CommandTaskDescriptor cmdTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = cmdTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Priority updatedPriority = cmdTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        Description updatedDescription = cmdTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        Location updatedLocation = cmdTaskDescriptor.getLocation().orElseGet(taskToEdit::getLocation);
        UniqueCategoryList updatedCategories = cmdTaskDescriptor.getCategories().orElseGet(taskToEdit::getCategories);
        DateTime updatedDateTime = cmdTaskDescriptor.getDateTime().orElseGet(taskToEdit::getDateTime);
        Recurrence updatedRecurrence = cmdTaskDescriptor.getRecurrence().orElseGet(taskToEdit::getRecurrence);
        Status updatedStatus = cmdTaskDescriptor.getStatus().orElseGet(taskToEdit::isCompleted);

        return new Task(updatedName, updatedPriority, updatedDescription, updatedLocation, updatedCategories,
                updatedDateTime, updatedRecurrence, updatedStatus);
    }

}
```
###### \java\savvytodo\logic\commands\MarkCommand.java
``` java
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";
    public static final String COMMAND_FORMAT = "mark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s\n";
    public static final String MESSAGE_MARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final int[] targetIndices;

    public MarkCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute()  throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<Integer> targettedIndices = new LinkedList<Integer>();
        LinkedList<Task> tasksToMark = new LinkedList<Task>();
        for (int targetIndex : targetIndices) {
            int filteredTaskListIndex = targetIndex - 1;
            if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            targettedIndices.add(targetIndex);
            tasksToMark.add((Task) lastShownList.get(filteredTaskListIndex));
        }

        int numOfSuccessfulMark = 0;
        StringBuilder resultSb = new StringBuilder();
        try {
            for (Task taskToMark : tasksToMark) {
                if (taskToMark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_MARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulMark++;
                    taskToMark = new Task(taskToMark);
                    taskToMark.setStatus(new Status(true));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToMark);
                    resultSb.append(String.format(MESSAGE_MARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }
        } catch (DuplicateTaskException e) {
            //ignore for completed
        }

        if (numOfSuccessfulMark > 0) {
            model.recordMark(numOfSuccessfulMark);
        }

        return new CommandResult(resultSb.toString());
    }

}
```
###### \java\savvytodo\logic\commands\UnmarkCommand.java
``` java
public class UnmarkCommand extends Command {

    public static final String COMMAND_WORD = "unmark";
    public static final String COMMAND_FORMAT = "unmark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the marked tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s\n";
    public static final String MESSAGE_UNMARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final int[] targetIndices;

    public UnmarkCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute()  throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<Integer> targettedIndices = new LinkedList<Integer>();
        LinkedList<Task> tasksToMark = new LinkedList<Task>();
        for (int targetIndex : targetIndices) {
            int filteredTaskListIndex = targetIndex - 1;
            if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            targettedIndices.add(targetIndex);
            tasksToMark.add((Task) lastShownList.get(filteredTaskListIndex));
        }

        int numOfSuccessfulUnmark = 0;
        StringBuilder resultSb = new StringBuilder();
        try {
            for (Task taskToUnmark : tasksToMark) {
                if (!taskToUnmark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulUnmark++;
                    taskToUnmark = new Task(taskToUnmark);
                    taskToUnmark.setStatus(new Status(false));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToUnmark);
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }
        } catch (DuplicateTaskException e) {
        }

        if (numOfSuccessfulUnmark > 0) {
            model.recordMark(numOfSuccessfulUnmark);
        }

        return new CommandResult(resultSb.toString());
    }

}
```
###### \java\savvytodo\logic\parser\MarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class MarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<int[]> intArray = ParserUtil.parseMultipleInteger(args);
        if (!intArray.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
        return new MarkCommand(intArray.get());
    }

}
```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Returns int[] if the String is parsed <br>
     * Returns a int[] populated by all elements in the given string
     * Returns a int[] if the given {@code Optional} is empty,
     * or if the int[] contained in the {@code Optional} is empty
     */
    public static Optional<int[]> parseMultipleInteger(String indicesString) {
        boolean parseError = false;

        String trimmedIndicesString = indicesString.trim();
        String[] indicesStringArray = null;
        int[] indicesArray = null;
        try {
            indicesStringArray = trimmedIndicesString.split(StringUtil.WHITESPACE_REGEX);
            indicesArray = Arrays.stream(indicesStringArray).mapToInt(Integer::parseInt).toArray();

            for (String index : indicesStringArray) {
                if (!StringUtil.isUnsignedInteger(index)) {
                    parseError = true;
                    break;
                }
            }
        } catch (NumberFormatException ex) {
            parseError = true;
        }

        if (parseError) {
            return Optional.empty();
        }
        return Optional.of(indicesArray);
    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
    * Splits a preamble string into ordered fields.
    * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
    *         the input, {@code Optional.empty()} otherwise.
    */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split(StringUtil.WHITESPACE_REGEX, numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Extract a {@code Optional<String> dateTime} into an {@code String[]} if {@code dateTime} is present.
     */
    public static String[] getDateTimeFromArgs(Optional<String> dateTime) {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return new String[] {StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]};
            } else {
                return dateTimeValues;
            }
        } else {
            return DateTime.DEFAULT_VALUES;
        }
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Extract a {@code Optional<String> recurrence} into an {@code String[]} if {@code recurrence} is present.
     */
    public static String[] getRecurrenceFromArgs(Optional<String> recurrence) {
        assert recurrence != null;
        return recurrence.isPresent() ? recurrence.get().split(StringUtil.WHITESPACE_REGEX) : Recurrence.DEFAULT_VALUES;
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> priority} into an {@code Optional<Priority>} if {@code priority} is present.
     */
    public static Optional<Priority> parsePriority(Optional<String> priority) throws IllegalValueException {
        assert priority != null;
        return priority.isPresent() ? Optional.of(new Priority(priority.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> location} into an {@code Optional<Location>} if {@code location} is present.
     */
    public static Optional<Location> parseLocation(Optional<String> location) throws IllegalValueException {
        assert location != null;
        return location.isPresent() ? Optional.of(new Location(location.get())) : Optional.empty();
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> dateTime} into an {@code Optional<DateTime>}
     * if {@code dateTime} is present.
     */
    public static Optional<DateTime> parseDateTime(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return Optional.of(new DateTime(StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]));
            } else {
                return Optional.of(new DateTime(dateTimeValues[ARRAY_FIELD_1], dateTimeValues[ARRAY_FIELD_2]));
            }
        } else {
            return Optional.empty();
        }
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> recurrence} into an {@code Optional<Recurrence>}
     * if {@code recurrence} is present.
     */
    public static Optional<Recurrence> parseRecurrence(Optional<String> recurrence) throws IllegalValueException {
        assert recurrence != null;
        if (recurrence.isPresent()) {
            String [] recurValues = recurrence.get().split(StringUtil.WHITESPACE_REGEX);
            return Optional
                    .of(new Recurrence(recurValues[ARRAY_FIELD_1], Integer.parseInt(recurValues[ARRAY_FIELD_2])));
        } else {
            return Optional.empty();
        }
    }

    /**
     * Parses a {@code Optional<String> description} into an {@code Optional<Description>}
     * if {@code description} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses {@code Collection<String> categories} into an {@code UniqueCategoryList}.
     */
    public static UniqueCategoryList parseCategories(Collection<String> categories) throws IllegalValueException {
        assert categories != null;
        final Set<Category> categorySet = new HashSet<>();
        for (String categoryName : categories) {
            categorySet.add(new Category(categoryName));
        }
        return new UniqueCategoryList(categorySet);
    }
}
```
###### \java\savvytodo\logic\parser\UnmarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UnmarkCommand object
 */
public class UnmarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the UnmarkCommand
     * and returns an UnmarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<int[]> intArray = ParserUtil.parseMultipleInteger(args);
        if (!intArray.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }
        return new UnmarkCommand(intArray.get());
    }

}
```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * @author A0140016B
     * Returns a string of conflicting datetimes within a specified datetime
     * @throws IllegalValueException
     * @throws DateTimeException
     */
    public String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck)
            throws DateTimeException, IllegalValueException {
        StringBuilder conflictingTasksStringBuilder = new StringBuilder(StringUtil.EMPTY_STRING);

        if (dateTimeToCheck.endValue == StringUtil.EMPTY_STRING) {
            return StringUtil.EMPTY_STRING;
        }

        appendConflictingTasks(conflictingTasksStringBuilder, dateTimeToCheck);

        return conflictingTasksStringBuilder.toString();
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    private void appendConflictingTasks(
            StringBuilder conflictingTasksStringBuilder,
            DateTime dateTimeToCheck) throws DateTimeException, IllegalValueException {

        int conflictCount = 1;
        for (ReadOnlyTask task : taskManager.getTaskList()) {
            if (task.isCompleted().value == Status.ONGOING
                    && DateTimeUtil.isDateTimeConflict(task.getDateTime(), dateTimeToCheck)) {
                conflictingTasksStringBuilder
                        .append(String.format(TASK_CONFLICTED, conflictCount, task.getAsText()));
                conflictCount++;
            }
        }
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

```
###### \java\savvytodo\model\task\Priority.java
``` java
/**
 * Represents a Task's priority in the task manager
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be 'low', 'medium' or 'high'";

    private static final int COMPARE_TO_SMALLER = -1;
    private static final int COMPARE_TO_EQUAL = 0;
    private static final int COMPARE_TO_GREATER = 1;

    /**
     * @author A0140016B
     * Get type enum object from it's name, ignoring cases
     * @param String recurrence type
     * @return Corresponding enum object
     */
    public enum Level {
        Low(1),
        Medium(2),
        High(3);

        private Integer value;

        Level(int value) {
            this.value = value;
        }

        int showInt() {
            return value;
        }
    }

    public final String value;
    private int level;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }

        if (priority.equalsIgnoreCase(Level.High.name())) {
            this.level = Level.High.ordinal();
        } else if (priority.equalsIgnoreCase(Level.Medium.name())) {
            this.level = Level.Medium.ordinal();
        } else {
            this.level = Level.Low.ordinal();
        }

        this.value = StringUtil.firstCharUpperCaseRestLowerCase(trimmedPriority);
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        boolean matches = false;
        for (Level level : Level.values()) {
            if (level.toString().equalsIgnoreCase(test)) {
                matches = true;
            }
        }
        return matches;
    }

```
###### \java\savvytodo\model\task\Priority.java
``` java
    @Override
    public int compareTo(Priority o) {
        if (this.level > o.level) {
            return COMPARE_TO_GREATER;
        } else if (this.level < o.level) {
            return COMPARE_TO_SMALLER;
        } else {
            return COMPARE_TO_EQUAL;
        }
    }

}
```
###### \java\savvytodo\model\task\Task.java
``` java
/**
 * @author A0140016B
 * Represents a Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Priority priority;
    private Description description;
    private Location location;
    private DateTime dateTime;
    private Recurrence recurrence;
    private Status isCompleted;

    private UniqueCategoryList categories;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories, dateTime, recurrence);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = new Status();
    }

    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence, Status status) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location,
                categories, dateTime, recurrence, status);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = status;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPriority(), source.getDescription(), source.getLocation(),
                source.getCategories(), source.getDateTime(), source.getRecurrence(), source.isCompleted());
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    public void setLocation(Location location) {
        assert location != null;
        this.location = location;
    }

    @Override
    public Location getLocation() {
        return location;
    }

    public void setDateTime(DateTime dateTime) {
        assert dateTime != null;
        this.dateTime = dateTime;
    }

    @Override
    public DateTime getDateTime() {
        return dateTime;
    }

    public void setRecurrence(Recurrence recurrence) {
        assert recurrence != null;
        this.recurrence = recurrence;
    }

    @Override
    public Recurrence getRecurrence() {
        return recurrence;
    }

    @Override
    public Status isCompleted() {
        assert isCompleted != null;
        return isCompleted;
    }

    public void setStatus(Status isCompleted) {
        this.isCompleted = isCompleted;
    }

    @Override
    public UniqueCategoryList getCategories() {
        return new UniqueCategoryList(categories);
    }

    /**
     * Replaces this task's categories with the categories in the argument category list.
     */
    public void setCategories(UniqueCategoryList replacement) {
        categories.setCategories(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setDescription(replacement.getDescription());
        this.setLocation(replacement.getLocation());
        this.setCategories(replacement.getCategories());
        this.setDateTime(replacement.getDateTime());
        this.setRecurrence(replacement.getRecurrence());
        this.setStatus(replacement.isCompleted());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, priority, description, location, categories, dateTime, recurrence, isCompleted);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\savvytodo\ui\BrowserPanel.java
``` java
/**
 * @author A0140016B The Browser Panel of the App.
 */
public class BrowserPanel extends UiPart<Region> {

    private static final String FXML = "BrowserPanel.fxml";

    private final StringProperty displayed = new SimpleStringProperty("");

    @FXML
    private AnchorPane browser;

    @FXML
    private TextArea browserDisplay;

    /**
     * @param placeholder
     *            The AnchorPane where the BrowserPanel must be inserted
     */
    public BrowserPanel(AnchorPane placeholder) {
        super(FXML);
        placeholder.setOnKeyPressed(Event::consume); // To prevent triggering
                                                     // events for typing inside
                                                     // the
                                                     // loaded Web page.
        browserDisplay.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(browserDisplay, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(browser);
    }

    public void loadTaskPage(ReadOnlyTask task) {
        displayed.setValue(build(task));
    }

    private String build(ReadOnlyTask task) {
        final StringBuilder builder = new StringBuilder();
        builder.append(task.getAsText());

        ArrayList<String> recurDates = DateTimeUtil.getRecurDates(task.getDateTime().startValue,
                task.getRecurrence().type.name(), task.getRecurrence().occurences);

        if (!recurDates.isEmpty()) {
            builder.append(StringUtil.SYSTEM_NEWLINE)
                   .append(StringUtil.SYSTEM_NEWLINE)
                   .append("Recurring dates (Start DateTime) are:")
                   .append(StringUtil.SYSTEM_NEWLINE)
                   .append(recurDates);
        }

        return builder.toString();
    }

    /**
     * Frees resources allocated to the browser.
     */
    public void freeResources() {
        browser = null;
    }

}
```
