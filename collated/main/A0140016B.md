# A0140016B
###### \java\savvytodo\commons\util\DateTimeUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to DateTime
 */
public class DateTimeUtil {

    private static final String TIME_ONLY_FORMAT = "HHmm";
    private static final String DATE_ONLY_FORMAT = "dd/MM/uuuu";
    private static final String DATE_FORMAT = "d/M/uuuu HHmm";
    private static final String DATE_STRING_FORMAT = "dd/MM/uuuu HHmm";

    public static final int FIRST_HOUR_OF_DAY = 0;
    public static final int FIRST_MINUTE_OF_DAY = 0;
    public static final int FIRST_SECOND_OF_DAY = 0;
    public static final int LAST_HOUR_OF_DAY = 23;
    public static final int LAST_MINUTE_OF_DAY = 59;
    public static final int LAST_SECOND_OF_DAY = 59;

    private static final String DAILY = "daily";
    private static final String WEEKLY = "weekly";
    private static final String MONTHLY = "monthly";
    private static final String YEARLY = "yearly";
    private static final int INCREMENT_FREQ = 1;

    private static final DateTimeFormatter DATE_ONLY_FORMATTER = DateTimeFormatter.ofPattern(DATE_ONLY_FORMAT);
    private static final DateTimeFormatter TIME_ONLY_FORMATTER = DateTimeFormatter.ofPattern(TIME_ONLY_FORMAT);

    public static final DateTimeFormatter DATE_FORMATTER = DateTimeFormatter.ofPattern(DATE_FORMAT)
            .withResolverStyle(ResolverStyle.STRICT);
    public static final DateTimeFormatter DATE_STRING_FORMATTER = DateTimeFormatter.ofPattern(DATE_STRING_FORMAT);

    public static final String MESSAGE_INCORRECT_SYNTAX = "It must be a valid date";

    private static final String MESSAGE_DURATION = "%1$s hr %2$s min";

    public static final String MESSAGE_FREE_TIME_SLOT = StringUtil.SYSTEM_NEWLINE + "%1$s. %2$shrs to %3$shrs (%4$s)";


    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return String[] with first index being the start DateTime and second index being the end
     *         date Time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) throws IllegalValueException {
        return NattyDateTimeParserUtil.parseStringToDateTime(dateTimeArgs);
    }

    /**
     * Extracts the new task's dateTime from the string arguments.
     * @return LocalDateTime
     */
    private static LocalDateTime parseStringToLocalDateTime(String dateTime) {
        return LocalDateTime.parse(dateTime, DATE_FORMATTER);
    }

    /**
     * Checks if given endDateTime is within today and the end of this week
     */
    public static boolean isWithinWeek(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            LocalDateTime endThisWeek = now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)).withHour(0).withMinute(0)
                    .withSecond(0);
            return endDateTime.isAfter(now) && endDateTime.isBefore(endThisWeek);
        }
    }

    /**
     * Checks if given event's endDateTime is before the end of today
     */
    public static boolean isOverDue(LocalDateTime endDateTime) {
        if (endDateTime == null) {
            return false;
        } else {
            LocalDateTime now = LocalDateTime.now();
            return endDateTime.isBefore(now);
        }
    }

    /**
     * Checks whether the dateTimeQuery falls within the range of the dateTimeSource
     * i.e. dateTimeQuery start is equals to or before the dateTimeSource end
     * && dateTimeQuery end is equals to or after the dateTimeSource start
     * Return false if task is a deadline or floating task (i.e. no start or end)
     * @param dateTimeSource is event compare to
     * @param dateTimeQuery  is event compare with
     */
    public static boolean isDateTimeWithinRange(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return !dateTimeOriginal.getEndDate().isBefore(dateTimeCompare.getStartDate())
                && !dateTimeOriginal.getStartDate().isAfter(dateTimeCompare.getEndDate());
    }

    /**
     * Checks whether the dateTimeQuery conflicts with the dateTimeSource
     * i.e. dateTimeQuery end should occur after the dateTimeSource start
     * and dateTimeQuery start should occur before the dateTimeSource end
     * Return false if task is a deadline or floating task (i.e. no start or end)
     */
    public static boolean isDateTimeConflict(DateTime dateTimeSource, DateTime dateTimeQuery)
            throws DateTimeException, IllegalValueException {
        if (!areEvents(dateTimeSource, dateTimeQuery)) {
            return false;
        }

        DateTime dateTimeOriginal = fillDateTime(dateTimeSource);
        DateTime dateTimeCompare = fillDateTime(dateTimeQuery);

        return dateTimeOriginal.getEndDate().isAfter(dateTimeCompare.getStartDate())
                && dateTimeOriginal.getStartDate().isBefore(dateTimeCompare.getEndDate());
    }

    private static DateTime fillDateTime(DateTime filledDateTime) throws IllegalValueException {

        filledDateTime.setEnd(parseStringToLocalDateTime(filledDateTime.endValue));
        filledDateTime.setStart(parseStringToLocalDateTime(filledDateTime.startValue));

        return filledDateTime;
    }

    /**
     * Check whether eventDateTime is an event
     * @param eventDateTime
     * @return whether task is an event
     */
    private static boolean isEvent(DateTime eventDateTime) {
        if (eventDateTime.getStartDate() == null
                || eventDateTime.getEndDate() == null) {
            return false;
        }

        return true;
    }

    /**
     * Check whether dateTimeSource and dateTimeQuery are events before they can be compared
     * @param dateTimeSource is the event compared to
     * @param dateTimeQuery is the event to compare
     * @return whether the task compared to and with are events
     */
    private static boolean areEvents(DateTime dateTimeSource, DateTime dateTimeQuery) {
        return isEvent(dateTimeSource) && isEvent(dateTimeQuery);
    }

    /**
     * @param dateToCheck cannot be null and it must be an event
     * @return an ArrayList<DateTime> of free slots in a specified date
     * else return an empty ArrayList
     */
    public static ArrayList<DateTime> getListOfFreeTimeSlotsInDate(
            DateTime dateToCheck,
            ArrayList<DateTime> listOfFilledTimeSlotsInDate) {
        ArrayList<DateTime> listOfFreeTimeSlots = new ArrayList<DateTime>();
        if (isEvent(dateToCheck)) {
            LocalDateTime startDateTime = dateToCheck.getStartDate();
            LocalDateTime endDateTime = dateToCheck.getEndDate();

            for (DateTime dateTime : listOfFilledTimeSlotsInDate) {
                if (dateTime.getStartDate() == null) {
                    continue;
                } else {
                    endDateTime = dateTime.getStartDate();
                }

                if (startDateTime.isBefore(endDateTime)) {
                    listOfFreeTimeSlots
                            .add(new DateTime(startDateTime, endDateTime));
                }

                if (startDateTime.isBefore(dateTime.getEndDate())) {
                    startDateTime = dateTime.getEndDate();
                }
            }

            if (startDateTime.isBefore(dateToCheck.getEndDate())) {
                listOfFreeTimeSlots.add(new DateTime(startDateTime, dateToCheck.getEndDate()));
            }
        }

        return listOfFreeTimeSlots;
    }

    /**
     * @return String from normal DateTime Object
     */
    public static String getDayAndDateString(DateTime dateTime) {
        StringBuilder sb = new StringBuilder();

        sb.append(dateTime.getEndDate().getDayOfWeek()
                .getDisplayName(TextStyle.FULL, Locale.ENGLISH)).append(",")
                .append(dateTime.getEndDate().format(DATE_ONLY_FORMATTER));

        return sb.toString();
    }

    /**
     * @return String of Free DateTime In Date
     */
    public static String getStringOfFreeDateTimeInDate(DateTime dateToCheck,
            ArrayList<DateTime> listOfFreeTimeSlotsInDate) {
        StringBuilder sb = new StringBuilder();

        sb.append(getDayAndDateString(dateToCheck))
                .append(":");

        int counter = 1;

        for (DateTime dateTime : listOfFreeTimeSlotsInDate) {
            sb.append(String.format(MESSAGE_FREE_TIME_SLOT, counter,
                    dateTime.getStartDate().format(TIME_ONLY_FORMATTER),
                    dateTime.getEndDate().format(TIME_ONLY_FORMATTER),
                    getDurationBetweenTwoLocalDateTime(dateTime.getStartDate(), dateTime.getEndDate())));
            counter++;
        }

        return sb.toString();
    }

    /**
     * Calculate the duration between 2 dates
     * @param startDateTime is not null
     * @param endDateTime is not null
     * @return String duration between 2 dates
     */
    public static String getDurationBetweenTwoLocalDateTime(
            LocalDateTime startDateTime, LocalDateTime endDateTime) {
        Duration duration = Duration.between(startDateTime, endDateTime);
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;

        return String.format(MESSAGE_DURATION, hours, minutes);
    }

    /**
     * Modify the date based on the new hour, min and sec
     * @return Date
     */
    public static Date setDateTime(Date toBeEdit, int hour, int min, int sec) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(toBeEdit);
        calendar.set(Calendar.HOUR_OF_DAY, hour);
        calendar.set(Calendar.MINUTE, min);
        calendar.set(Calendar.SECOND, sec);
        toBeEdit = calendar.getTime();

        return toBeEdit;
    }

    /**
     * @param recurDate usually is the start date of an event
     * @param freqType is the frequency based on recurrance
     * Modifies the recurDate based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    public static String getRecurDate(String recurDate, String freqType) {
        LocalDateTime date = LocalDateTime.parse(recurDate, DATE_FORMATTER);

        switch (freqType.toLowerCase()) {
        case DAILY:
            date = date.plusDays(INCREMENT_FREQ);
            break;
        case WEEKLY:
            date = date.plusWeeks(INCREMENT_FREQ);
            break;
        case MONTHLY:
            date = date.plusMonths(INCREMENT_FREQ);
            break;
        case YEARLY:
            date = date.plusYears(INCREMENT_FREQ);
            break;
        }

        recurDate = date.format(DATE_STRING_FORMATTER);
        return recurDate;
    }

    /**
     * @param recurDates usually is the start date of an event
     * @param freqType is the frequency based on recurrence
     * @param noOfRecurr is the number of recurrence
     * Modifies the recurDates based on the frequency for recurring tasks.
     * freqType cannot be null or None
     */
    public static ArrayList<String> getRecurDates(String recurDate, String freqType, int noOfRecurr) {
        ArrayList<String> recurrDates = new ArrayList<String>();

        for (int i = 0; i < noOfRecurr; i++) {
            recurDate = getRecurDate(recurDate, freqType);
            recurrDates.add(getRecurDate(recurDate, freqType));
        }

        return recurrDates;
    }

    /**
     * @param dateTime in LocalDateTime which has been initialized with a date
     * @param hour in int that is to be changed in hour
     * @param min in int that is to be changed in min
     * @param sec in int that is to be changed in sec
     * @return LocalDateTime which is modified with new time
     */
    public static LocalDateTime setLocalTime(LocalDateTime dateTime, int hour, int min, int sec) {
        return LocalDateTime.of(dateTime.getYear(), dateTime.getMonth(), dateTime.getDayOfMonth(), hour, min, sec);
    }
}
```
###### \java\savvytodo\commons\util\EnumUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to Enum
 */
public class EnumUtil {
    /**
     * for seed properties
     * @param e
     * @return String []
     */
    public static String[] getNames(Class<? extends Enum<?>> e) {
        return Arrays.stream(e.getEnumConstants()).map(Enum::name).toArray(String[]::new);
    }
}
```
###### \java\savvytodo\commons\util\NattyDateTimeParserUtil.java
``` java
/**
 * @author A0140016B
 * Utility methods related to NattyDateTimeParser
 */
public class NattyDateTimeParserUtil {

    private static final int EMPTY_GROUP_SIZE = 0;
    private static final int END_DATE_GROUP_SIZE = 1;
    private static final int START_AND_END_DATE_GROUP_SIZE = 2;
    private static final int GROUP_ONE = 0;
    private static final int GROUP_TWO = 1;
    private static final int CHILD_ONE = 0;
    private static final int CHILD_TWO = 1;

    private static final SimpleDateFormat CONVERT_TIME_FORMAT = new SimpleDateFormat("dd/MM/yyyy HHmm");

    private static final String DASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})-(\\d{1,2})";
    private static final String SLASH_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})/(\\d{1,2})";
    public static final String EQUAL_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2})=(\\d{1,2})";
    public static final String EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT = "(\\b\\d{1,2}) = (\\d{1,2})";

    private static final String DASH_CONNECTOR_DATE_REPLACEMENT = "$2-$1";
    private static final String SLASH_CONNECTOR_DATE_REPLACEMENT = "$2/$1";
    private static final String WORD_NOW = "NOW";
    private static final String NATTY_EXPLICT_TIME_PREFIX = "EXPLICIT_TIME";

    private static Parser parser;

    /**
     * To create one instance of parser so that computation would be relatively faster
     * @return Parser instance if it exist else return a new Parser with TimeZone
     */
    private static Parser getInstance() {
        if (parser == null) {
            return new Parser(TimeZone.getDefault());
        } else {
            return parser;
        }
    }

    /**
     * Extracts the new task's dateTime from the string arguments using natty.
     * @param String dateTimeArgs
     * @return String[] with first index being the startDate time and second index being the end
     *         date time
     */
    public static String[] parseStringToDateTime(String dateTimeArgs) throws IllegalValueException {
        String endDateTime = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String formattedDateTimeArg = convertToUSDateFormat(dateTimeArgs);

        parser = getInstance();
        List<DateGroup> groups = parser.parse(formattedDateTimeArg);

        if (isInvalidDateTimeArg(dateTimeArgs, groups)) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_DATETIME);
        }

        if (groups.size() > EMPTY_GROUP_SIZE) {
            DateGroup group = groups.get(GROUP_ONE);
            if (group.getDates().size() == END_DATE_GROUP_SIZE) {
                return retrieveEndDate(group);
            }

            if (group.getDates().size() == START_AND_END_DATE_GROUP_SIZE) {
                return retrieveStartAndEndDate(group);
            }
        }

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Change the date format to US date format.
     * @param unformattedDateTime
     * @return formatted DateTime in US format
     */
    private static String convertToUSDateFormat(String unformattedDateTime) {
        String formattedDateTime = unformattedDateTime.trim()
                .replaceAll(DASH_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(SLASH_CONNECTOR_DATE_FORMAT, SLASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT)
                .replaceAll(EQUAL_WITH_SPACE_CONNECTOR_DATE_FORMAT, DASH_CONNECTOR_DATE_REPLACEMENT);
        return formattedDateTime;
    }

    /**
     * Change the date format to Asia date format.
     * @param unformattedDateTime
     * @return formatted DateTime in Asia format
     */
    private static String convertToAsiaDateFormat(Date unformattedDateTime) {
        return CONVERT_TIME_FORMAT.format(unformattedDateTime);
    }

    /**
     * Checks if the DateTime is a invalid format.
     * @return true if the given DateTime is invalid
     */
    private static boolean isInvalidDateTimeArg(String dateTimeArg, List<DateGroup> groups) {
        return (dateTimeArg.trim().length() > 0 && groups.size() == EMPTY_GROUP_SIZE);
    }

    /**
     * Retrieve end date time from natty group for deadlines
     */
    private static String[] retrieveEndDate(DateGroup group) {
        String treeString = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date date;

        treeString = group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();

        date = group.getDates().get(GROUP_ONE);
        if (!isTimePresent(treeString) && !isWordNowPresent(group.getText())) {
            date = DateTimeUtil.setDateTime(date,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        endDateTime = convertToAsiaDateFormat(date);

        return new String[] {StringUtil.EMPTY_STRING, endDateTime};
    }

    /**
     * Retrieve the variables from Natty Parser for events
     */
    private static String[] retrieveStartAndEndDate(DateGroup group) {
        String treeFirstString = StringUtil.EMPTY_STRING;
        String treeSecondString = StringUtil.EMPTY_STRING;
        String startDateTime = StringUtil.EMPTY_STRING;
        String endDateTime = StringUtil.EMPTY_STRING;
        Date dateOne;
        Date dateTwo;

        treeFirstString =
                group.getSyntaxTree().getChild(CHILD_ONE).toStringTree();
        treeSecondString =
                group.getSyntaxTree().getChild(CHILD_TWO).toStringTree();
        dateOne = group.getDates().get(GROUP_ONE);
        dateTwo = group.getDates().get(GROUP_TWO);

        if (!isTimePresent(treeFirstString) && !isWordNowPresent(group.getText())) {
            dateOne = DateTimeUtil.setDateTime(dateOne,
                    DateTimeUtil.FIRST_HOUR_OF_DAY,
                    DateTimeUtil.FIRST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        if (!isTimePresent(treeSecondString) && !isWordNowPresent(group.getText())) {
            dateTwo = DateTimeUtil.setDateTime(dateTwo,
                    DateTimeUtil.LAST_HOUR_OF_DAY,
                    DateTimeUtil.LAST_MINUTE_OF_DAY,
                    DateTimeUtil.FIRST_SECOND_OF_DAY);
        }

        startDateTime = CONVERT_TIME_FORMAT.format(dateOne);
        endDateTime = CONVERT_TIME_FORMAT.format(dateTwo);

        return new String[] {startDateTime, endDateTime};
    }

    /**
     * Checks if time is present
     * @param treeString
     * @return true if time is present
     */
    private static boolean isTimePresent(String treeString) {
        return treeString.contains(NATTY_EXPLICT_TIME_PREFIX);
    }

    /**
     * Checks if word now is present
     * @param arg
     * @return true if word now is present
     */
    private static boolean isWordNowPresent(String arg) {
        return arg.toLowerCase().contains(WORD_NOW.toLowerCase());
    }
}
```
###### \java\savvytodo\commons\util\StringUtil.java
``` java
    /**
     * @author A0140016B
     * @param string cannot be null
     * @param string Should be trimmed
     * @return string of first character upper case and the rest lower case
     */
    public static String firstCharUpperCaseRestLowerCase(String string) {
        return string.substring(0, 1).toUpperCase() + string.substring(1).toLowerCase();
    }

}
```
###### \java\savvytodo\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager. "
            + "Parameters: NAME [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " "
            + "Project Meeting dt/05/10/2016 1400 = 05/10/2016 1800 r/weekly 2 c/CS2103 "
            + "d/Discuss about roles and milestones";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final ArrayList<Task> toAddList;

    String conflictingTaskList = StringUtil.EMPTY_STRING;

    /**
     * Creates an AddCommand using raw values.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String priority, String description, String location, String[] dateTime,
            String[] recurrence, Set<String> categories) throws IllegalValueException {
        final Set<Category> categorySet = new HashSet<>();
        toAddList = new ArrayList<Task>();
        for (String categoryName : categories) {
            categorySet.add(new Category(categoryName));
        }

        this.addToTaskList(name, priority, description, location, dateTime, recurrence, categorySet);
    }

    /**
     * Creates list of toAdd tasks using raw values.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    private void addToTaskList(String name, String priority, String description, String location, String[] dateTime,
            String[] recurrence, Set<Category> categorySet) throws IllegalValueException {
        Task toAdd;

        int numTasks = 1;
        if (recurrence != null
                && Integer.parseInt(recurrence[1]) > Integer.parseInt(Recurrence.DEFAULT_VALUES[1])) {
            recurrence[0] = Recurrence.Type.valueOfIgnoreCase(recurrence[0]).name();
            numTasks += Integer.parseInt(recurrence[1]);
        }

        for (int i = 0; i < numTasks; i++) {
            if (i != 0) {
                modifyDateTime(dateTime, recurrence, 0);
                modifyDateTime(dateTime, recurrence, 1);
            }

            toAdd = new Task(
                    new Name(name),
                    new Priority(priority),
                    new Description(description),
                    new Location(location),
                    new UniqueCategoryList(categorySet),
                    new DateTime(dateTime),
                    new Recurrence(Recurrence.DEFAULT_VALUES)
            );

            toAdd.setStatus(new Status());
            toAddList.add(toAdd);
        }
    }

    /**
     * change recurring date Time;
     */
    private void modifyDateTime(String[] dateTime, String[] recurrence,
            int dateTimeIndex) {
        if (dateTime[dateTimeIndex] != null
                && dateTime[dateTimeIndex].length() > 0) {
            dateTime[dateTimeIndex] = DateTimeUtil.getRecurDate(dateTime[dateTimeIndex], recurrence[0]);
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            for (Task toAdd : toAddList) {
                conflictingTaskList += model.getTaskConflictingDateTimeWarningMessage(toAdd.getDateTime());
                model.addTask(toAdd);
            }
            return new CommandResult(messageSummary());

        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (DateTimeException e) {
            throw new CommandException(DateTimeUtil.MESSAGE_INCORRECT_SYNTAX);
        } catch (IllegalValueException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        } catch (IllegalArgumentException e) {
            throw new CommandException(e.getMessage());
        }
    }

    /**
     * Method for conflicting tasks
     * @param conflictingTaskList
     * @return messageSummary
     */
    private String messageSummary() {
        String summary = StringUtil.EMPTY_STRING;

        for (Task toAdd : toAddList) {
            summary += String.format(MESSAGE_SUCCESS, toAdd);
            if (toAddList.size() > 1) {
                summary += "\n";
            }
        }
        if (!conflictingTaskList.isEmpty()) {
            summary += StringUtil.SYSTEM_NEWLINE
                    + Messages.MESSAGE_CONFLICTING_TASKS_WARNING
                    + conflictingTaskList;
        }
        return summary;
    }
}
```
###### \java\savvytodo\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the at least one details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "[NAME] [dt/START_DATE = END_DATE] [l/LOCATION] [p/PRIORITY_LEVEL] "
            + "[r/RECURRING_TYPE NUMBER_OF_RECURRENCE] [c/CATEGORY] [d/DESCRIPTION]...\n"
            + "Example: " + COMMAND_WORD + " 1 c/CS2103 d/Complete group project component";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final int filteredTaskListIndex;
    private final CommandTaskDescriptor cmdTaskDescriptor;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, CommandTaskDescriptor cmdTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert cmdTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.cmdTaskDescriptor = new CommandTaskDescriptor(cmdTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, cmdTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code cmdTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, CommandTaskDescriptor cmdTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = cmdTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Priority updatedPriority = cmdTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        Description updatedDescription = cmdTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        Location updatedLocation = cmdTaskDescriptor.getLocation().orElseGet(taskToEdit::getLocation);
        UniqueCategoryList updatedCategories = cmdTaskDescriptor.getCategories().orElseGet(taskToEdit::getCategories);
        DateTime updatedDateTime = cmdTaskDescriptor.getDateTime().orElseGet(taskToEdit::getDateTime);
        Recurrence updatedRecurrence = cmdTaskDescriptor.getRecurrence().orElseGet(taskToEdit::getRecurrence);
        Status updatedStatus = cmdTaskDescriptor.getStatus().orElseGet(taskToEdit::isCompleted);
        TimeStamp timeStamp = taskToEdit.getTimeStamp();
        return new Task(updatedName, updatedPriority, updatedDescription, updatedLocation, updatedCategories,
                updatedDateTime, updatedRecurrence, updatedStatus, timeStamp);
    }

}
```
###### \java\savvytodo\logic\commands\MarkCommand.java
``` java
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";
    public static final String COMMAND_FORMAT = "mark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s\n";
    public static final String MESSAGE_MARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final int[] targetIndices;

    public MarkCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute()  throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<Integer> targettedIndices = new LinkedList<Integer>();
        LinkedList<Task> tasksToMark = new LinkedList<Task>();
        for (int targetIndex : targetIndices) {
            int filteredTaskListIndex = targetIndex - 1;
            if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            targettedIndices.add(targetIndex);
            tasksToMark.add((Task) lastShownList.get(filteredTaskListIndex));
        }

        int numOfSuccessfulMark = 0;
        StringBuilder resultSb = new StringBuilder();
        try {
            for (Task taskToMark : tasksToMark) {
                if (taskToMark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_MARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulMark++;
                    taskToMark = new Task(taskToMark);
                    taskToMark.setStatus(new Status(true));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToMark);
                    resultSb.append(String.format(MESSAGE_MARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }
        } catch (DuplicateTaskException e) {
            //ignore for completed
        }

        if (numOfSuccessfulMark > 0) {
            model.recordMark(numOfSuccessfulMark);
        }

        return new CommandResult(resultSb.toString());
    }

}
```
###### \java\savvytodo\logic\commands\UnmarkCommand.java
``` java
public class UnmarkCommand extends Command {

    public static final String COMMAND_WORD = "unmark";
    public static final String COMMAND_FORMAT = "unmark INDEX [MORE_INDEX]";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the marked tasks identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s\n";
    public static final String MESSAGE_UNMARK_TASK_FAIL = "Task %1$s is already marked!\n";

    public final int[] targetIndices;

    public UnmarkCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute()  throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        LinkedList<Integer> targettedIndices = new LinkedList<Integer>();
        LinkedList<Task> tasksToMark = new LinkedList<Task>();
        for (int targetIndex : targetIndices) {
            int filteredTaskListIndex = targetIndex - 1;
            if (filteredTaskListIndex >= lastShownList.size() || filteredTaskListIndex < 0) {
                return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            targettedIndices.add(targetIndex);
            tasksToMark.add((Task) lastShownList.get(filteredTaskListIndex));
        }

        int numOfSuccessfulUnmark = 0;
        StringBuilder resultSb = new StringBuilder();
        try {
            for (Task taskToUnmark : tasksToMark) {
                if (!taskToUnmark.isCompleted().value) {
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_FAIL, targettedIndices.peekFirst()));
                } else {
                    numOfSuccessfulUnmark++;
                    taskToUnmark = new Task(taskToUnmark);
                    taskToUnmark.setStatus(new Status(false));
                    model.updateTask(targettedIndices.peekFirst() - 1, taskToUnmark);
                    resultSb.append(String.format(MESSAGE_UNMARK_TASK_SUCCESS, targettedIndices.peekFirst()));
                }
                targettedIndices.removeFirst();
            }
        } catch (DuplicateTaskException e) {
        }

        if (numOfSuccessfulUnmark > 0) {
            model.recordMark(numOfSuccessfulUnmark);
        }

        return new CommandResult(resultSb.toString());
    }

}
```
###### \java\savvytodo\logic\parser\AddCommandParser.java
``` java
/**
 * @author A0140016B
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_PRIORITY, PREFIX_DATE_TIME,
                PREFIX_RECURRENCE, PREFIX_DESCRIPTION, PREFIX_LOCATION, PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);

        try {

            return new AddCommand(argsTokenizer.getPreamble().get(),
                    argsTokenizer.getValue(PREFIX_PRIORITY).orElse(Priority.Level.Medium.toString()),
                    argsTokenizer.getValue(PREFIX_DESCRIPTION).orElse(Description.DESCRIPTION_DEFAULT_VALUES),
                    argsTokenizer.getValue(PREFIX_LOCATION).orElse(Location.LOCATION_DEFAULT_VALUES),
                    ParserUtil.getDateTimeFromArgs(argsTokenizer.getValue(PREFIX_DATE_TIME)),
                    ParserUtil.getRecurrenceFromArgs(argsTokenizer.getValue(PREFIX_RECURRENCE)),
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_CATEGORY)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\savvytodo\logic\parser\MarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class MarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<int[]> intArray = ParserUtil.parseMultipleInteger(args);
        if (!intArray.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
        return new MarkCommand(intArray.get());
    }

}
```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Returns int[] if the String is parsed <br>
     * Returns a int[] populated by all elements in the given string
     * Returns a int[] if the given {@code Optional} is empty,
     * or if the int[] contained in the {@code Optional} is empty
     */
    public static Optional<int[]> parseMultipleInteger(String indicesString) {
        boolean parseError = false;

        String trimmedIndicesString = indicesString.trim();
        String[] indicesStringArray = null;
        int[] indicesArray = null;
        try {
            indicesStringArray = trimmedIndicesString.split(StringUtil.WHITESPACE_REGEX);
            indicesArray = Arrays.stream(indicesStringArray).mapToInt(Integer::parseInt).toArray();

            for (String index : indicesStringArray) {
                if (!StringUtil.isUnsignedInteger(index)) {
                    parseError = true;
                    break;
                }
            }
        } catch (NumberFormatException ex) {
            parseError = true;
        }

        if (parseError) {
            return Optional.empty();
        }
        return Optional.of(indicesArray);
    }

    /**
     * Returns a new Set populated by all elements in the given list of strings
     * Returns an empty set if the given {@code Optional} is empty,
     * or if the list contained in the {@code Optional} is empty
     */
    public static Set<String> toSet(Optional<List<String>> list) {
        List<String> elements = list.orElse(Collections.emptyList());
        return new HashSet<>(elements);
    }

    /**
    * Splits a preamble string into ordered fields.
    * @return A list of size {@code numFields} where the ith element is the ith field value if specified in
    *         the input, {@code Optional.empty()} otherwise.
    */
    public static List<Optional<String>> splitPreamble(String preamble, int numFields) {
        return Arrays.stream(Arrays.copyOf(preamble.split(StringUtil.WHITESPACE_REGEX, numFields), numFields))
                .map(Optional::ofNullable)
                .collect(Collectors.toList());
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Extract a {@code Optional<String> dateTime} into an {@code String[]} if {@code dateTime} is present.
     * @throws IllegalValueException for invalid dateTime
     */
    public static String[] getDateTimeFromArgs(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return new String[] {StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]};
            } else {
                return dateTimeValues;
            }
        } else {
            return DateTime.DEFAULT_VALUES;
        }
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Extract a {@code Optional<String> recurrence} into an {@code String[]} if {@code recurrence} is present.
     */
    public static String[] getRecurrenceFromArgs(Optional<String> recurrence) {
        assert recurrence != null;
        return recurrence.isPresent() ? recurrence.get().split(StringUtil.WHITESPACE_REGEX) : Recurrence.DEFAULT_VALUES;
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<Name> parseName(Optional<String> name) throws IllegalValueException {
        assert name != null;
        return name.isPresent() ? Optional.of(new Name(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> priority} into an {@code Optional<Priority>} if {@code priority} is present.
     */
    public static Optional<Priority> parsePriority(Optional<String> priority) throws IllegalValueException {
        assert priority != null;
        return priority.isPresent() ? Optional.of(new Priority(priority.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> location} into an {@code Optional<Location>} if {@code location} is present.
     */
    public static Optional<Location> parseLocation(Optional<String> location) throws IllegalValueException {
        assert location != null;
        return location.isPresent() ? Optional.of(new Location(location.get())) : Optional.empty();
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> dateTime} into an {@code Optional<DateTime>}
     * if {@code dateTime} is present.
     */
    public static Optional<DateTime> parseDateTime(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;
        if (dateTime.isPresent()) {
            String [] dateTimeValues = DateTimeUtil.parseStringToDateTime(dateTime.get());
            if (dateTimeValues.length == SIZE_OF_DATE_TIME_INPUT) {
                return Optional.of(new DateTime(StringUtil.EMPTY_STRING, dateTimeValues[ARRAY_FIELD_1]));
            } else {
                return Optional.of(new DateTime(dateTimeValues[ARRAY_FIELD_1], dateTimeValues[ARRAY_FIELD_2]));
            }
        } else {
            return Optional.empty();
        }
    }

```
###### \java\savvytodo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> recurrence} into an {@code Optional<Recurrence>}
     * if {@code recurrence} is present.
     */
    public static Optional<Recurrence> parseRecurrence(Optional<String> recurrence) throws IllegalValueException {
        assert recurrence != null;
        if (recurrence.isPresent()) {
            String [] recurValues = recurrence.get().split(StringUtil.WHITESPACE_REGEX);
            return Optional
                    .of(new Recurrence(recurValues[ARRAY_FIELD_1], Integer.parseInt(recurValues[ARRAY_FIELD_2])));
        } else {
            return Optional.empty();
        }
    }

    /**
     * Parses a {@code Optional<String> description} into an {@code Optional<Description>}
     * if {@code description} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses {@code Collection<String> categories} into an {@code UniqueCategoryList}.
     */
    public static UniqueCategoryList parseCategories(Collection<String> categories) throws IllegalValueException {
        assert categories != null;
        final Set<Category> categorySet = new HashSet<>();
        for (String categoryName : categories) {
            categorySet.add(new Category(categoryName));
        }
        return new UniqueCategoryList(categorySet);
    }
}
```
###### \java\savvytodo\logic\parser\UnmarkCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UnmarkCommand object
 */
public class UnmarkCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the UnmarkCommand
     * and returns an UnmarkCommand object for execution.
     */
    public Command parse(String args) {
        Optional<int[]> intArray = ParserUtil.parseMultipleInteger(args);
        if (!intArray.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }
        return new UnmarkCommand(intArray.get());
    }

}
```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * @author A0140016B
     * Returns a string of conflicting datetimes within a specified datetime
     * @throws IllegalValueException
     * @throws DateTimeException
     */
    public String getTaskConflictingDateTimeWarningMessage(DateTime dateTimeToCheck)
            throws DateTimeException, IllegalValueException {
        StringBuilder conflictingTasksStringBuilder = new StringBuilder(StringUtil.EMPTY_STRING);

        if (dateTimeToCheck.endValue == StringUtil.EMPTY_STRING) {
            return StringUtil.EMPTY_STRING;
        }

        appendConflictingTasks(conflictingTasksStringBuilder, dateTimeToCheck);

        return conflictingTasksStringBuilder.toString();
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * @param conflictingTasksStringBuilder to generate conflicting tasks in String
     * @return number of task conflicted
     */
    private int appendConflictingTasks(
            StringBuilder conflictingTasksStringBuilder,
            DateTime dateTimeToCheck) throws DateTimeException, IllegalValueException {

        int conflictCount = 0;
        int conflictPosition = 1;
        for (ReadOnlyTask task : taskManager.getTaskList()) {
            if (task.isCompleted().value == Status.ONGOING
                    && DateTimeUtil.isDateTimeConflict(task.getDateTime(), dateTimeToCheck)) {
                conflictingTasksStringBuilder
                        .append(String.format(TASK_CONFLICTED, conflictPosition, task.getAsText()));
                conflictCount++;
            }
            conflictPosition++;
        }
        return conflictCount;
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    public void updateFilteredTaskListByDateTime(DateTime dateTime) {
        updateFilteredTaskList(new PredicateExpression(new DateTimeQualifier(dateTime)));
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        @Override
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().name, keyword)).findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\savvytodo\model\ModelManager.java
``` java
    /**
     * Qualifier to sort by DateTime specified
     * Task type must be event
     */
    private class DateTimeQualifier implements Qualifier {

        private LocalDateTime startDateTime;
        private LocalDateTime endDateTime;
        private DateTime dateTimeQuery;

        public DateTimeQualifier (DateTime dateTime) {
            if (dateTime.getStartDate() != null) {
                startDateTime = DateTimeUtil.setLocalTime(dateTime.getStartDate(),
                        DateTimeUtil.FIRST_HOUR_OF_DAY,
                        DateTimeUtil.FIRST_MINUTE_OF_DAY,
                        DateTimeUtil.FIRST_SECOND_OF_DAY);
                endDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.LAST_HOUR_OF_DAY,
                        DateTimeUtil.LAST_MINUTE_OF_DAY,
                        DateTimeUtil.LAST_SECOND_OF_DAY);
            } else {
                startDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.FIRST_HOUR_OF_DAY,
                        DateTimeUtil.FIRST_MINUTE_OF_DAY,
                        DateTimeUtil.FIRST_SECOND_OF_DAY);
                endDateTime = DateTimeUtil.setLocalTime(dateTime.getEndDate(),
                        DateTimeUtil.LAST_HOUR_OF_DAY,
                        DateTimeUtil.LAST_MINUTE_OF_DAY,
                        DateTimeUtil.LAST_SECOND_OF_DAY);
            }

            try {
                dateTimeQuery = new DateTime();
                dateTimeQuery.setStart(startDateTime);
                dateTimeQuery.setEnd(endDateTime);
            } catch (IllegalValueException e) {
                dateTimeQuery = new DateTime(LocalDateTime.now(), LocalDateTime.now());
                e.printStackTrace();
            }
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            try {
                return DateTimeUtil.isDateTimeWithinRange(task.getDateTime(), dateTimeQuery);
            } catch (DateTimeException e) {
                e.printStackTrace();
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
            return false;
        }
    }

}
```
###### \java\savvytodo\model\task\Priority.java
``` java
/**
 * Represents a Task's priority in the task manager
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should be 'low', 'medium' or 'high'";

    private static final int COMPARE_TO_SMALLER = -1;
    private static final int COMPARE_TO_EQUAL = 0;
    private static final int COMPARE_TO_GREATER = 1;

```
###### \java\savvytodo\model\task\Priority.java
``` java
    /**
     * @author A0140016B
     * Get type enum object from it's name, ignoring cases
     * @param String recurrence type
     * @return Corresponding enum object
     */
    public enum Level {
        Low(1),
        Medium(2),
        High(3);

        private Integer value;

        Level(int value) {
            this.value = value;
        }

        int showInt() {
            return value;
        }
    }

    public final String value;
    private int level;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }

        if (priority.equalsIgnoreCase(Level.High.name())) {
            this.level = Level.High.ordinal();
        } else if (priority.equalsIgnoreCase(Level.Medium.name())) {
            this.level = Level.Medium.ordinal();
        } else {
            this.level = Level.Low.ordinal();
        }

        this.value = StringUtil.firstCharUpperCaseRestLowerCase(trimmedPriority);
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        boolean matches = false;
        for (Level level : Level.values()) {
            if (level.toString().equalsIgnoreCase(test) || Integer.toString(level.showInt()).equalsIgnoreCase(test)
                    || isValidCharPriority(level, test)) {
                matches = true;
            }
        }
        return matches;
    }

    /**
     * Return true if string matches first char
     */
    private static boolean isValidCharPriority(Level level, String test) {
        return level.toString().substring(0, 1).equalsIgnoreCase(test);
    }

```
###### \java\savvytodo\model\task\Priority.java
``` java
    @Override
    public int compareTo(Priority o) {
        if (this.level > o.level) {
            return COMPARE_TO_GREATER;
        } else if (this.level < o.level) {
            return COMPARE_TO_SMALLER;
        } else {
            return COMPARE_TO_EQUAL;
        }
    }

}
```
###### \java\savvytodo\model\task\Recurrence.java
``` java
/**
 * @author A0140016B
 *
 * Represents Task's Recurrence in the task manager Guarantees: immutable;
 * is valid as declared in {@link #isValidRecurrence(String, int)} *
 */
public class Recurrence {

    /**
     * @author A0140016B
     *
     * Specifies the type of recurrence for the task
     * Defaults to none if it is a one-time task
     */
    public enum Type {
        None,
        Daily,
        Weekly,
        Monthly,
        Yearly;

        /**
         * Get type enum object from it's name, ignoring cases
         * @param String recurrence type
         * @return Corresponding enum object
         * @throws IllegalArgumentException if invalid input
         */
        public static Type valueOfIgnoreCase(String reType) {
            for (Type type : Type.values()) {
                if (type.toString().equalsIgnoreCase(reType)
                        || type.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                    return type;
                }
            }
            throw new IllegalArgumentException(MESSAGE_RECURR_NOT_MATCH);
        }

        /**
         * Compare enum object with String to see if it matches whole string or first char
         * @param String retype cannot be null
         * @return boolean of whether string matches enum object
         */
        public static boolean matches(String reType) {
            for (Type type : Type.values()) {
                if (type.toString().equalsIgnoreCase(reType)
                        || type.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                    return true;
                }
            }
            return false;
        }

        /**
         * Compare enum object with String to see if it matches
         * @param String retype cannot be null
         * @return boolean of wheather string matches enum object
         */
        public static boolean isNone(String reType) {
            if (Type.None.toString().equalsIgnoreCase(reType)
                    || Type.None.toString().substring(0, 1).equalsIgnoreCase(reType)) {
                return true;
            } else {
                return false;
            }
        }

    }

    public int occurences;
    public Type type;

    public static final String MESSAGE_RECURR_CONSTRAINTS =
            "If recurrence type is NONE, occurences can only be 0";
    public static final String MESSAGE_RECURR_NOT_MATCH =
            "Task recurrence type should be 'none', 'daily', 'weekly', 'monthly' or 'yearly'";
    public static final String[] DEFAULT_VALUES = {Type.None.toString(), "0"};

    /**
     * Default constructor
     * @throws IllegalValueException
     * @throws NumberFormatException
     */
    public Recurrence() throws NumberFormatException, IllegalValueException {
        this(DEFAULT_VALUES);
    }

    /**
     * Validates given Recurrence.
     * @throws IllegalValueException if given Recurrence is invalid.
     */
    public Recurrence(String type, int occurences) throws IllegalValueException {
        assert type != null;
        String trimmedType = type.trim();
        if (!Type.matches(type)) {
            throw new IllegalValueException(MESSAGE_RECURR_NOT_MATCH);
        }
        if (!isValidRecurrence(trimmedType, occurences)) {
            throw new IllegalValueException(MESSAGE_RECURR_CONSTRAINTS);
        }
        this.type = Type.valueOfIgnoreCase(trimmedType);
        this.occurences = occurences;
    }

    /**
     * Constructor when given input as String array
     * @param recurrence string array
     * @throws IllegalValueException
     * @throws NumberFormatException
     */
    public Recurrence(String[] recurrence) throws NumberFormatException, IllegalValueException {
        this(recurrence[0], Integer.parseInt(recurrence[1]));
    }

    /**
     * Returns true if a given string is a valid task Recurrence and num is more than -1.
     */
    public static boolean isValidRecurrence(String type, int numOfTimes) {
        if (numOfTimes >= 0 && Type.matches(type)) {
            if (Type.isNone(type) && numOfTimes != 0) {
                return false;
            } else {
                return true;
            }
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        return this.type.toString() + "(" + this.occurences + ")";
    }

}
```
###### \java\savvytodo\model\task\Task.java
``` java
/**
 * @author A0140016B
 * Represents a Task in the task manager.
 * Guarantees: details are present and not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Priority priority;
    private Description description;
    private Location location;
    private DateTime dateTime;
    private Recurrence recurrence;
    private Status isCompleted;
    private TimeStamp timeStamp;

    private UniqueCategoryList categories;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories,
                dateTime, recurrence);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = new Status();
        this.timeStamp = new TimeStamp();
    }

    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence, TimeStamp timeStamp) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location, categories,
                dateTime, recurrence, timeStamp);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = new Status();
        this.timeStamp = new TimeStamp(timeStamp);
    }

    public Task(Name name, Priority priority, Description description, Location location,
            UniqueCategoryList categories, DateTime dateTime, Recurrence recurrence,
            Status status, TimeStamp timeStamp) {
        assert !CollectionUtil.isAnyNull(name, priority, description, location,
                categories, dateTime, recurrence, status);
        this.name = name;
        this.priority = priority;
        this.description = description;
        this.location = location;
        this.categories = new UniqueCategoryList(categories); //protect internal categories from changes in the arg list
        this.dateTime = dateTime;
        this.recurrence = recurrence;
        this.isCompleted = status;
        this.timeStamp = new TimeStamp(timeStamp);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPriority(), source.getDescription(), source.getLocation(),
                source.getCategories(), source.getDateTime(), source.getRecurrence(),
                source.isCompleted(), source.getTimeStamp());
    }


    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    public void setLocation(Location location) {
        assert location != null;
        this.location = location;
    }

    @Override
    public Location getLocation() {
        return location;
    }

    public void setDateTime(DateTime dateTime) {
        assert dateTime != null;
        this.dateTime = dateTime;
    }

    @Override
    public DateTime getDateTime() {
        return dateTime;
    }

    public void setRecurrence(Recurrence recurrence) {
        assert recurrence != null;
        this.recurrence = recurrence;
    }

    @Override
    public Recurrence getRecurrence() {
        return recurrence;
    }

    @Override
    public Status isCompleted() {
        assert isCompleted != null;
        return isCompleted;
    }

    public void setStatus(Status isCompleted) {
        this.isCompleted = isCompleted;
    }

    @Override
    public UniqueCategoryList getCategories() {
        return new UniqueCategoryList(categories);
    }

    /**
     * Replaces this task's categories with the categories in the argument category list.
     */
    public void setCategories(UniqueCategoryList replacement) {
        categories.setCategories(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setDescription(replacement.getDescription());
        this.setLocation(replacement.getLocation());
        this.setCategories(replacement.getCategories());
        this.setDateTime(replacement.getDateTime());
        this.setRecurrence(replacement.getRecurrence());
        this.setStatus(replacement.isCompleted());
        this.setTimeStamp(replacement.getTimeStamp());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, priority, description, location, categories, dateTime, recurrence,
                isCompleted, timeStamp);
    }

    @Override
    public String toString() {
        return getAsText();
    }


```
###### \java\savvytodo\model\task\UniqueTaskList.java
``` java
    /**
     * @return ObservableList<Task> for sorting purpose
     */
    public ObservableList<Task> getInternalList() {
        return internalList;
    }

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list, list is then sorted by the data and time it was added
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
        internalList.sort((ReadOnlyTask task1, ReadOnlyTask task2) -> task1.getTimeStamp().getDateTimeAdded().compareTo(
                task2.getTimeStamp().getDateTimeAdded()));
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedTask}.
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;

        Task taskToUpdate = internalList.get(index);
        if (!taskToUpdate.equals(editedTask) && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        taskToUpdate.resetData(editedTask);
        // TODO: The code below is just a workaround to notify observers of the updated task.
        // The right way is to implement observable properties in the Task class.
        // Then, TaskCard should then bind its text labels to those observable properties.
        internalList.set(index, taskToUpdate);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {
            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                && this.internalList.equals(
                ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {}

}
```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by ascending priority - Low to High
     */
    public void sortByAscendingPriority() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o1.getPriority().compareTo(o2.getPriority());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by descending priority - High to Low
     */
    public void sortByDescendingPriority() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o2.getPriority().compareTo(o1.getPriority());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by ascending end dateTime
     */
    public void sortByAscendingDatetime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o1.getDateTime().compareTo(o2.getDateTime());
            }
        });
    }

```
###### \java\savvytodo\model\TaskManager.java
``` java
    /**
     * Sorts internal list by descending end dateTime
     */
    public void sortByDescendingDatetime() {
        this.tasks.getInternalList().sort(new Comparator<Task>() {
            @Override
            public int compare(Task o1, Task o2) {
                return o2.getDateTime().compareTo(o1.getDateTime());
            }
        });
    }
```
###### \java\savvytodo\ui\BrowserPanel.java
``` java
/**
 * @author A0140016B The Browser Panel of the App.
 */
public class BrowserPanel extends UiPart<Region> {

    private static final String FXML = "BrowserPanel.fxml";

    private final StringProperty displayed = new SimpleStringProperty("");

    @FXML
    private AnchorPane browser;

    @FXML
    private TextArea browserDisplay;

    /**
     * @param placeholder
     *            The AnchorPane where the BrowserPanel must be inserted
     */
    public BrowserPanel(AnchorPane placeholder) {
        super(FXML);
        placeholder.setOnKeyPressed(Event::consume); // To prevent triggering
                                                     // events for typing inside
                                                     // the
                                                     // loaded Web page.
        browserDisplay.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(browserDisplay, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(browser);
    }

    public void loadTaskPage(ReadOnlyTask task) {
        displayed.setValue(build(task));
    }

    private String build(ReadOnlyTask task) {
        final StringBuilder builder = new StringBuilder();
        builder.append(task.getAsText());

        ArrayList<String> recurDates = DateTimeUtil.getRecurDates(task.getDateTime().startValue,
                task.getRecurrence().type.name(), task.getRecurrence().occurences);

        if (!recurDates.isEmpty()) {
            builder.append(StringUtil.SYSTEM_NEWLINE)
                   .append(StringUtil.SYSTEM_NEWLINE)
                   .append("Recurring dates (Start DateTime) are:")
                   .append(StringUtil.SYSTEM_NEWLINE)
                   .append(recurDates);
        }

        return builder.toString();
    }

    /**
     * Frees resources allocated to the browser.
     */
    public void freeResources() {
        browser = null;
    }

}
```
